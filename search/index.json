[{"content":"多线程的基本概念 线程的概念 线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程内的实际执行单元。进程是资源分配的最小单位，而线程是调度的最小单位。与进程的创建不同，线程在创建时除了会申请线程本身所必须的资源之外，其他的资源比如内存空间、文件描述符等资源会使用进程中已经存在的资源，并且一个进程中的多个线程会共享本进程中的内存空间、文件描述符等大部分资源。需要注意的是，线程不具备进程级别的隔离性，一旦所属进程崩溃，虽然不会影响到其他进程，但该进程内的所有线程都将终止。\n多线程与多进程的区别 在Python中，多线程和多进程都是实现多并发执行的技术，但它们在多个方面存在显著的区别:\n调度 多线程(Threading):线程是操作系统能够进行运算调度的最小单位，被包含在进程之中，是进程中的实际运作单位。由于线程共享进程的内存空间，操作系统可以在同一进程空间中快速切换不同线程，实现并发执行。 多进程(Multiprocessing):进程是操作系统分配资源的独立单位。每个进程都有自己的内存空间，因此进程间的通信比线程要复杂，但在pvtbon中，多进程可以利用多核处理器的多个核心，实现真正的并行计算。 GIL(全局解释器锁) 多线程:CPython解释器(Python的主要实现)有一个全局解释器锁(GIL)，它确保同一时刻只有一个线程执行Python字节码。因此，即使在多核CPU上，使用多线程的Python程序也无法实现真正的并行计算，GIL限制了线程在执行CPU密集型任务时的效率。 多进程:每个Python进程都有自己的Python解释器和内存空间，因此GIL不会限制多进程。多进程可以绕过GIL，充分利用多核处理器进行并行计算。 GIL锁的优点:\n简化内存管理:由于GIL确保同一时刻只有一个线程在执行，因此CPython的内存管理可以设计得更加简单。 它不需要考虑多个线程同时修改对象的情况，从而避免了复杂的多线程内存回收问题。 易于实现:GIL简化了CPython解释器的实现，因为它不需要考虑多线程并发执行时的数据竞争和同步问题。3.单线程性能:在没有多线程竞争的情况下，单个线程的性能可以保持得很好，因为G儿L避免了不必要的上下文切换。 Python中的多线程 在Pvthon中，多线程是通过threading模块实现的，该模块允许程序员创建、启动、同步多个线程，并提供了一系列的API来支持线程间同步和通信。 在Python中，使用threading模块中的Thread类来创建线程，Thread类创建对象时的参数为:\nthreading.Thread(group=None, target=None, name=None, args=(), kwargs=None, *,daemon=None) 以下是各个参数的说明:\ngroup: 应该始终为 None，保留供未来扩展使用。·target: 是一个可调用的对象(函数)，该线程启动时，这个对象将被调用。如果不提供，则不会运行任何东西。 name: 线程名称。默认情况下，将分配一个唯一的名称。 args: 传递给 target 函数的位置参数，默认是一个元组。 kwargs: 传递给 target 函数的关键字参数，默认是一个字典, daemon:指定线程是否为守护线程。如果设置为True，则该线程会在主线程结束时自动退出。如果是None，则继承自创建它的线程。 以下是一些 Thread 类提供的主要方法和属性:\nstart():启动线程活动。使用start去启动线程，会调用run()方法，它会创建一个新的线程来执行run()方法中的代码。 run():表示线程活动的方法。可以在子类中重写此方法，重写之后执行重写的代码。通常不需要直接调用rur方法，应该调用start方法去启动线程，如果直接调用run方法(没有通过start方法去启动线程)那么run方法中的代码将在当前线程中同步执行，而不是在新的线程中执行。 join(timeout=None):等待线程终止。timeout 参数是可选的，表示等待的最长时间(以秒为单位)。如果没有指定 timeout，则该方法将无限期等待。 is alive():返回线程是否还活着。 getName():返回线程名。 setName(name):设置线程名。 isDaemon():返回线程的守护状态。 setDaemon(daemonic): 设置线程的守护状态，必须在start开始前设置 name: 线程名称 ident: 线程标识符 daemon：线程的守护状态 不传参的列子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import time from functools import total_ordering from threading import Thread def func1(): print(\u0026#39;func1 is running\u0026#39;) time.sleep(2) print(\u0026#39;func1 is done\u0026#39;) def func2(): print(\u0026#39;func2 is running\u0026#39;) time.sleep(2) print(\u0026#39;func2 is done\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: start = time.time() #创建一个线程运行func2 process = Thread(target=func1) process.start() #主程序运行func1 func1() #等待线程结束 process.join() total = time.time() - start print(f\u0026#34;程序运行了{total}秒\u0026#34;) Timer Timer，也被称为定时器，它允许你在一定时间后执行一个函数或者可调用的对象。Timer 类是 Thread 类的一个子类，因此它具有线程的所有特性，并且可以用来在后台执行定时务。 以下是 Timer 类的基本用法和特性:\n1 class threading.Timer(interval, function, args=None, kwargs=None) 参数说明 interva:一个浮点数或整数，表示在执行 function之前需要等待的时间(以秒为单位)。function:一个可调用的对象，当定时器到期时将被执行。 args:传递给 function的位置参数元组, kwargs: 传递给 function 的关键字参数字典。 实例方法 start():启动定时器。 Timer将在指定的时间间隔后开始执行目标函数。 cancel():取消定时器。定时器未启动时，此方法无效。 定时器简单应用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import time import threading def get_time(): current_time = time.time() #将时间戳格式化 formatted_time = time.strftime(\u0026#39;%Y-%m-%d %H:%M:%S\u0026#39;, time.localtime(current_time)) print(formatted_time) if __name__ == \u0026#39;__main__\u0026#39;: #出啊关键一个定时器，5秒后打印时间戳 timer = threading.Timer(5, get_time) timer.start() print(\u0026#34;等待打印时间戳中\u0026#34;) timer.join() 线程间通信 消息队列 在Python中，queue 模块提供了一个适用于多线程环境的队列实现，这里介绍三种消息队列，分别是Queue,LifoQueue和PriorityQueue.\nQueue 最常用的消息队列，遵循先进先出的原则，使用queue.queue 创建。\n1 queue.Queue(maxsize=0) maxsize:队列的最大尺寸。如果设置为小于或等于0的数，则队列的尺寸是无限的。以下是 queue.\nqueue类的方法:\nQueue.qsize():返回队列中当前有几条消息\nQueue.empty():如果队列为空，返回True，否则返回 Fa1se。\nQueue.fu11():如果队列已满(达到最大尺寸)，返回 True，否则返回 False。\nQueue.put(item,block=True, timeout=None):将item 放入队列。如果 block是True 目 timeout是 None(默认)，则在必要时阻塞至有空闲的插槽。如果 timeout 是正数，将最多阻塞 timeout 秒，如果在这段时间内没有可用的插槽，将引发 queue.Fu11 异常。\nQueue.put_nowait(item):相当于 Queue.put(item，block=Fa1se)。如果队列已满，立即引发queue.Fu11 异常。\nQueue.get(b1ock=True，timeout=None):从队列中移除并返回一个元素。如果 b1ock 是 True 且timeout 是 None(默认)，则在必要时阻塞至队列中有项目可用。如果 timeout 是正数，将最多阻塞timeout 秒，如果在这段时间内没有项目可用，将引发 queue.Empty 异常。\nQueue.get_nowait():相当于 Queue.get(b1ock=Fa1se)。如果队列为空，立即引发 queue.Empty 异常。\nQueue.task_done():指示之前入队的一个任务已经完成。由队列的消费者线程使用。每个Queue.get()调用之后，需要调用 queue.task_done()告诉队列该任务处理完成。\nQueue.join():阻塞调用线程，直到队列中的所有项目都被处理完(即队列中每个项目都有一个对应的Queue.task_done()调用)\n应用举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from threading import Thread from queue import Queueimport time def process1(thread_queue): print(\u0026#39;准备接收数据\u0026#39;) # 接收数据 received_data = thread_queue.get() print(\u0026#39;接收到的数据为:\u0026#39;，received_data) if __name__ ==\u0026#39;__main__\u0026#39;: thread queue = Queue(5) t1= Thread(target=process1,args=(thread_queue,)) t1.start() time.sleep(2) thread_queue.put(\u0026#39;hello\u0026#39;)#发送数据 t1.join()#等待线程结束 LifoQueue 用于实现后进先出(Last In, First Out)的队列。与标准的 queue.Queue(先进先出，FIFO)不同，Lifoqueue允许最后被放入队列的元素最先被取出，使用queue.Lifoqueue 创建。\n1 queue.LifoQueue(maxsize=0）) maxsize:队列的最大尺寸。如果设置为小于或等于0的数，则队列的尺寸是无限的,。\n常用方法:\nLifoQueue.put(item,block=True,timeout=None):将item 放入队列。如果 block 是True 目timeout 是 None(默认)，则在必要时阻塞至有空闲的插槽。如果 timeout 是正数，将最多阻塞timeout 秒，如果在这段时间内没有可用的插槽，将引发完全异常。 LifoQueue.put_nowait(item):相当于 LifoQueue.put(item,block=False)。如果队列已满，立即引发完全异常。 LifoQueue.get(b1ock=True，timeout=None):从队列中移除并返回一个元素。如果 block是 True 日timeout 是 None(默认)，则在必要时阻塞至队列中有项目可用。如果 timeout 是正数，将最多阻塞timeout 秒，如果在这段时间内没有项目可用，将引发完全异常， Lifoqueue.get_nowait():相当于 LifoQueue.get(block=False)。如果队列为空，立即引发完全异常 Lifoqueue.qsize():返回队列中的项目数量 Lifoqueue.empty():如果队列为空，返回True Lifoqueue.full():如果队列满了，返回True 消息存入与取出顺序：\n1 2 3 4 5 6 7 8 9 10 11 import queue # 创建一个 LifoQueue Lifo_queue = queue.LifoQueue(5) #向LifoQueue 中放入元素 Lifo_queue.put(\u0026#39;First\u0026#39;) Lifo_queue.put(\u0026#39;Second\u0026#39;) Lifo_queue.put(\u0026#39;Third\u0026#39;) #从LifoQueue 中取出元素 print(lifo_queue.get()) print(lifo_queue.get()) print(lifo_queue.get()) PriorityQueue PriorityQueue用于实现优先级队列，在 priorityqueue 中，元素被赋予一个优先级值，并且元素会按照优先级顺序被取出。在Python中，使用queue.priorityqueue来创建。\n1 queue.PriorityQueue(maxsize=0) maxsize:队列的最大尺寸。如果设置为小于或等于0的数，则队列的尺寸是无限的。\n常用方法:\nPriorityqueue.put((priority,item)，block=True,timeout=None):将item 放入队列，并为其指定一个优先级 priority。如果 b1ock 是 True 目 timeout 是 None(默认)，则在必要时阻塞至有空闲的插槽。如果 timeout 是正数，将最多阻塞 timeout 秒，如果在这段时间内没有可用的插槽，将引发完全异常。 Priorityqueue.put_nowait(item, priority):相当于 priorityoueue.put((item, priority), b1ock=Fa1se)。如果队列已满，立即引发完全异常 Priorityqueue.get(block=True，timeout=None):从队列中移除并返回一个元素。如果 b1ock 是 True月 timeout 是 None(默认)，则在必要时阻塞至队列中有项目可用。如果 timeout 是正数，将最多阻塞timeout 秒，如果在这段时间内没有项目可用，将引发完全异常。 Priorityoueue.get_nowait():相当于 PriorityQueue.get(block=False)。如果队列为空，立即引发完全异常。 Priorityqueue.qsize():返回队列中的项目数量， 消息存入与取出顺序：\n1 2 3 4 5 6 7 8 9 10 11 import queue #创建一个 PriorityQueue priority_queue = queue.PriorityQueue(5) #向 PriorityQueue 中放入元素 priority_queue.put((2,\u0026#39;Task1\u0026#39;)) priority_queue.put((0,\u0026#39;Task2\u0026#39;)) priority_queve.put((1,\u0026#39;Task3\u0026#39;)) #从PriorityQueue 中取出元素 print(priority_queue.get()) print(priority_queue.get()) print(priority_queue.get()) 线程同步 在Python中，线程同步指的是一系列用于控制多个线程访问共享资源的方法和规则，以避免数据不一致或竞争条件(Race condition)的问题。由于线程是操作系统调度的基本单元，它们可能会同时操作同一份数据，这可能会导致数据错误或难以预测的结果。以下是几种常见的线程同步机制:\n锁(Locks):锁是最基本的同步机制。在Python中，可以通过 threading 模块的 Lock 类来实现。锁可以确保同一时间只有一个线程能够访问共享资源。线程在访问资源前必须获取锁，访问结束后释放锁。 信号量(Semaphores):信号量是一个更高级的同步机制，它维护了一个计数器，线程可以增加或减少这个计数器。如果计数器为零，则线程会阻塞，直到其他线程增加计数器。 事件(Events):事件是一种线程之间的通信机制。\u0026ndash;个线程可以设置事件，而其他线程可以等待该事件的发生。这可以用来通知一个或多个线程某个条件已经满足。 条件变量(Condition Variables):条件变量通常与互斥锁一起使用，它允许线程在某个条件不满足时挂起(等待)，直到另一个线程通知条件已经满足。 屏障(Barriers):屏障是一种同步机制，允许多个线程在某个点上同步，直到所有线程都到达屏障点后，才能继续执行。 锁 Python中的线程锁也有两个，一个是普通的锁Lock，另一个是可重入锁RLock。使用与进程类似。\n屏障 在Python的 threading模块中，Barrier(屏障)是一种同步机制，用于让一组线程在某个点上同步。当所有线程都到达屏障点时，它们将继续执行;如果任何线程没有到达屏障点，则所有线程都会被阻塞，直到所有线程都到达。 创建Barrier对象 要使用 Barrier，首先需要导入threading模块，并创建一个Barrier对象:\n1 2 import threading barrier= threading.Barrier(parties,action=None, timeout=None) parties:屏障点上需要等待的线程数量 action(可选):当所有线程到达屏障点时，可以执行的一个函数。 timeout(可选):默认的超时时间，如果wait没有指定时间将使用这个时间。 Barrier的方法与属性:\nwait(timeout):阻塞线程，直到屏障被释放。如果所有线程都到达屏障点，屏障将被释放，所有线程继续执行;如果任何线程没有到达，所有线程将被阻塞。如果提供了timeout，这里的timeout会优先于创建Barrier对象时提供的timeout参数。改函数会返回一个整数，取值在0~(n-1)之间。 reset():重置Barrier为默认的初始状态。如果Barrier中仍有线程等待释放，将会引发异常。 abort():使Barrier处于破损状态，这将导致任何现有和未来对wait()方法的调用失败并引发异常。 parties:冲出Barrier所需要的线程数量。 n_waiting:当前时刻正在Barrier中阻塞的线程数量。 broken:一个布尔值，表示Barrier是否为破损态。 线程池 线程池的概念 线程池维护一个工作线程的集合，用于执行任务。当任务到达时，线程池可以选择一个空闲的线程来处理任务，而不是为每个任务都创建一个新的线程。\n为什么使用线程池 降低资源消耗:线程的创建和销毁开销较大，通过重用线程，可以降低这些开销。 提高响应速度:不需要等待线程的创建就能立即执行任务。 提高线程的可管理性:线程池可以统一管理线程的创建、销毁、数量等内容。 Python中的线程池实现 concurrent.futures,ThreadPoolExecutor: Python标准库中的 concurrent.futures 模块提供了一个高层次的异步执行接口，ThreadPoo1Executor是其提供的线程池实现。\n线程池的创建 1 2 concurrent,futures.ThreadPoolExecutor(max_workers=None, thread_name_prefix=\u0026#39;\u0026#39; initializer=None，initargs=()) 参数解释：\nmax_workers:线程池中线程的最大数量。如果设置为None 或未指定，为min(32,os.cpu_count()+4)，这个默认值会保留至少5个工作线程用于 I/O密集型任务。 对于那些释放了 GIL 的 CPU 密集型任务，它最多会使用 32 个 CPU 核心。这样能够避免在多核机器上不知不觉地使用大量资源。 thread_name_prefix:线程名称的前缀，有助于调试时识别线程。 initia1izer:一个可选的可调用对象，每个工作线程在启动时都会调用它。这可以用来执行线程的初始化操作，例如设置线程局部存储。 initargs:一个元组，其中包含传递给initializer的可调用对象的参数。 initia1izer和 initargs 参数通常用于为每个线程设置特定的环境或上下文。\n线程池的方法 submit(fn,args, kwargs):提交一个可调用的函数 fn和必要的参数args 和 kwargs 到线程池中执行。这个方法返回一个 Future 对象。 map(func, *iterables,timeout=None, chunksize=1):它允许你将一个函数 func 应用于多个可迭代对象iterab1es 中的元素，并且并行地在多个线程上执行这些函数调用。 timeout是可选参数，用于设置阻塞等待每个任务完成的最大秒数。如果 timeout 被触发，将引发 concurrent.futures.TimeoutErrorchunksize 是可选参数，用于指定每次切割几个参数给func，不过只对进程池有效果，对线程池无效。返回的结果是一个迭代器。 shutdown(wait=True): 关闭线程池，停止接收新任务。如果wait 参数为True，则等待所有已提交的任务完成。当使用with语句创建线程池时，with语句会在结束后自动调用shutdown。 ","date":"2024-10-17T00:00:00Z","image":"https://UPPO8.github.io/Mybolg/images/PythonCourse/R-C.png","permalink":"https://UPPO8.github.io/Mybolg/p/python-%E5%A4%9A%E7%BA%BF%E7%A8%8B/","title":"Python-多线程"},{"content":"串行执行、并发执行、并行执行 串行执行、并发执行和并行执行是计算机程序执行方式的三个不同阶段，它们的发展历史与计算机硬件和软件的进步紧密相关。\n串行执行 串行执行属于最早期的程序执行方式，是指任务按顺序一个接一个地执行在串行执行中，一个任务必须等待前一个任务完成后才能开始执行。这种执行方式简单、易于控制，但效率较低，特别是在处理大量任务时，因为CPU的云算能力没有得到充分利用。在早期计算机系统中非常普遍，因为当时的硬件资源有限，且CPU的能力远不如现在，无法同时执行多个任务，并且大部分计算机都只有一个CPU。因此程序设计通常采用串行执行，在这一时期计算机主要用于科学计算和军事目的，任务通常是简单的、顺序的，不需要复杂的并发或并行处理。\n串行执行具有以下几个特点:\n顺序性:任务必须按照一定的顺序执行，一个任务完成后才能开始下一个任务。 易于管理:由于任务按顺序执行，因此管理和调试相对简单。 资源利用率低:在执行单个任务时，CPU的运算能力没有得到充分利用，可能导致效率低下。 并发执行 随着计算机技术的发展和多用户需求的出现，单一串行执行方式逐渐显得力不从心。此时操作系统引入了进程的概念，且它允许多个程序在内存中同时存在，操作系统负责调度这些程序，通过时间片轮转等技术使得它们可以交替使用CPU，从而达到一种看似并发的效果。这一技术提高了CPU的利用率，因为当一个程序等待I/0操作时，CPU可以切换到另一个程序执行。这一时期，计算机开始被广泛应用于商业和科学领域，需要处理更多的数据和更复杂的任务。\n并发执行具有以下几个特点:\n效率提高:通过在不同的任务之间切换，提高了CPU的利用率 响应性增强:在交互式应用中，可以提高用户体验，比如用户在等待某个计算密集型任务的同时还可以进行其他操作。 复杂性增加:并发编程需要处理诸如同步、死锁等问题，增加了开发难度。 并行执行 随着晶体管和集成电路技术的进步，计算机的处理器能力得到了显著提升，并且制造出了包含多个处理器的计算机系统，这促进了并行计算的发展。并行执行能够显著提高计算机处理大量数据和复杂计算的能力，特别是在科学研究、天气预报、数据分析等领域。随着时间的发展，并行计算逐渐成为高性能计算(HPC)的核心技术，并行处理技术也在多核处理器和分布式系统中得到了广泛应用。\n并行执行具有以下几个特点:\n高性能:通过将任务分解为多个子任务并分配给不同的处理器执行，可以显著提高执行速度. 复杂性高:并行编程通常需要对算法进行重新设计以支持并行化，同时还需要考虑数据共享、同步等问题。 可扩展性：并行系统的设计往往考虑到了将来扩展的可能性，可以以通过增加处理器数量来提高性能。 I/O密集型任务与CPU密集型任务 IO密集型任务和CPU密集型任务时根据任务执行时主要消耗的资源类型来分类的。\nI/O密集型任务 10密集型任务是指那些任务执行过程中，大部分时间花费在输入/输出操作上，而不是CPU计算。这些任务的性能瓶颈通常在于磁盘读写、网络通信或用户输入等10操作的速度。以下是I0密集型任务的特点:\n等待时间:任务大部分时间在等待10操作完成。 CPU使用率:CPU使用率通常不高，因为CPU在等待I0操作完成期间常常处于空闲状态。 并发优势:IO密集型任务可以通过并发执行来提高效率，因为在等待一个IO操作完成时，CPU可以切换到另一个任务执行。 比如：文件处理、网络请求处理、数据库操作等。\nCPU密集型任务 CPU密集型任务是指大部分时间用于CPU计算的任务，设计大量的运算、判断和数据处理。这些任务的性能瓶颈通常在于CPU的计算能力。以下是CPU密集型任务的特点：\n计算时间：任务大部分在进行计算 CPU使用率：CPU使用率通常很高，因为任务需要大量的CPU资源 CPU密集型任务可以通过并行执行在不同的处理器核心上不同时运行来提高性能。 对程序执行的影响 对于IO密集型任务，多线程通常是一个较好的选择，因为它可以在单个进程内有效地处理多个IO操作，因为进程间切换的开销而降低效率。 对于CPU密集型任务，多进程可以更好地利用多核CPU的能力，因为每个进程可以在不同的核心上运行，从而提真整休的处理速度。 多进程的概念 进程介绍 进程:进程就是程序的一次执行过程，就是一个正在执行的任务，一段程序的每一次运行都会产生一个或多个进程。进程是有生命周期的，大部分会随着程序的运行而创建，随着程序的结束而终止，也可以去手动结束进程。在操作系统中，进程是操作系统进行资源分配和调度的基本单位。每个进程都有自己的私有地址空间、执行堆栈、程序计数器、局部变量以及其他系统资源(如文件描述符、网络连接等)等。通俗的说，一个正在运行的程序就是一个进程，比如QQ、微信等，但也有可能这个程序会生成多个进程。\n进程和程序的关系 进程:进程是程序的一次执行过程，它是动态的，具备生命周期，在程序运行时存在，程序执行完毕及用户主动结束、系统错误等都会导致进程结束。\n程序:程序是静态的，没有生命周期，在磁盘上存放，由一系列指令和数据组成的文件，这些文件可以被操作系统加载到内存中并执行。\n进程的种类 在Windows操作系统中，进程可以根据其创建方式和执行环境被分为几种类型。以下是一些常见的Windows进程类型:\n系统进程：\n这些进程是操作系统启动时由系统本身创建的，它们负责管理系统的核心功能，如内存管理、设备驱动程序、安全性和其他系统级服务。\n例如:Isass.exe(本地安全认证子系统服务)、wininit,exe(Windows初始化进程)。\n**服务进程(Service Process)：\n这些进程通常在系统启动时或按需启动，它们在后台运行，提供网络、安全、系统维护等服务，通常不直接与用户交互。\n例如:DHCP client(管理IP地址分配)\n用户进程(User Process):\n这些是由用户启动的应用程序创建的进程，用于执行特定任务，如文字处理、网页浏览、游戏等。\n例如:winword.exe(Microsoft Word)、chrome.exe(Google Chrome浏览器)。\n交互式进程(Interactive Process):\n这些是与用户交互的进程，它们通常在用户登录并直接与操作系统交互时运行。\n例如:命令提示符(cmd.exe)或PowerShell(powershe11.exe)。\nPID PID是“进程标识符”(Process ldentifier)的缩写，它是一个由操作系统分配给每个进程的唯一数字(大于等于0)。在操作系统中，每个进程都会被赋予一个唯一的PID，以便系统可以追踪和管理这些进程。\n唯一性:在一个操作系统中，每个正在运行的进程都有一个唯一的PID。即使在进程结束后，该PID通常也不会立即被重新分配给其他进程，以避免混淆。 进程管理:操作系统使用PID来识别和管理进程。例如，可以使用PID来发送信号给进程(如终止信号)、检查进程的状态、或者调整进程的优先级。 系统资源:PID还用于关联进程使用的系统资源，如打开的文件、网络连接和内存分配。 父进程与子进程:每个进程除了有自己的PID外，还有一个与之关联的父PID(PPID)。父PID是指启动该进程的进程的PID。 工具和命令:在命令行界面中，可以使用各种工具和命令来査看和管理进程，如 ps(Unix-ike系统)task1ist(Windows)等，这些工具通常会显示进程的PID。 kil命令:在Windows中，可以在CMD中通过ki+PID 来终止该进程的运行。\n多进程的概念 多进程(Multiprocessing)是指在同一时间内同时执行多个程序的技术或能力，每个进程都有自己的内存空间.文件描述符及其他系统资源。以下是多进程的一些特点:\n并发执行:多进程可以在多核或多处理器系统上实现真正的并行执行，即不同的进程可以在不同的CPU核心上同时运行。 资源分配:每个进程通常拥有独立的内存空间，这意味着它们不共享内存，这减少了资源共享带来的复杂性和潜在的问题。 独立性:全局变量在多个进程中不共享资源，进程之间的数据是独立的，默认是互不影响的。且由于进程间相对独立，一个进程的失败通常不会影响到其他进程，这提高了系统的稳定性和可靠性。 进程间通信(IPC):进程间通信机制(如管道、消息队列、共享内存、信号量等)用于允许进程之间交换数据和同步操作。 创建多进程 在Python中，multiprocessing库提供了创建和管理进程的方法，它允许程序员创建进程，并提供了一系列的API来支持进程间数据共享、同步和通信。 在Python中，使用multiprocessing中的Process类来创建子进程，Process类创建对象时的参数为:\n1 multiprocessing.Process(group=None, target=None, name=None, args=(), kwargs={},*,daemon=None) 以下是各个参数的说明:\ngroup:通常不使用，是为将来可能的扩展预留的。 target:表示调用对象，即子进程要执行的任务。这个参数通常是一个函数的名字 name:进程的名称。默认情况下，进程名称为Process-N，其中N是进程的序号。可以通过这个参数来指定一个自定义的名称。 args:表示调用 target函数时传递的参数元组， kwargs:表示调用target函数时传递的参数字典。 daemon:如果设置为True，则子进程将是一个守护进程。当主进程结束时，所有守护进程都将被终止。默认值为 None ，表示继承当前进程的守护进程设置。 创建的对象也拥有一些方法，分别是:\nstart():启动进程。这将执行在创建process对象时指定的target函数，调用start时会自动调用run。 run():此方法用于定义进程启动时执行的操作。默认情况下，它调用传递给 target 参数的函数。如果 join([timeout]):主进程等待子进程终止或直到达到指定的超时时间。如果 timeout 被省略或为 None，则主进程将一直停留在这里。 is_a1ive():返回一个布尔值，表示进程是否仍然在运行。 terminate():强行终止进程，且不会进行任何清理操作。 如果该进程创建了子进程，那么这个子进程就变成了僵尸进程，如果p还保存了一个锁，那么这个锁也不会被释放，会变成死锁。 ki11():终止进程。在Unix上，这是通过发送SIGKILL信号实现的;在Windows上，则是通过调用TerminateProcess . c1ose():关闭进程。此方法释放Process对象所持有的资源，如果子进程仍在进行，调用此方法将是错误的。 除此之外，还有属性:\nname:返回或设置进程的名称。 pid:返回进程的PID。 exitcode:返回进程的退出代码，如果进程未结束，就返回None，负值-N表示子进程被信号N终止，正常终 止返回0。 authkey:返回或设置进程间通信的密钥，用于进程间通信的身份认证，了解即可。 PID获取示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import time from multiprocessing import Process import os def say(): print(\u0026#34;子PID：\u0026#34;,os.getpid()) print(\u0026#34;父PID：\u0026#34;,os.getppid()) time.sleep(3) if __name__==\u0026#34;__main__\u0026#34;: p1 = Process(target = say) p1.start() print(\u0026#39;main PID:\u0026#39;,os.getpid()) p1.join() 进程间通信 进程间通信(Inter-Process Communication,IPC)是指在不同进程之间传送数据或信号的一些方法。在多进程程序中，IPC是非常重要的，因为它允许进程协同工作、共享数据或同步操作。以下是几种常见的进程间通信机制:\n管道(pipe) 管道是一种在父子进程间或兄弟进程间进行通信的机制。Python的mu1tiprocessing 模块提供了Pipe()函数可以用来创建管道。\n创建管道 1 parent_conn,child_conn=pipe() 使用 multiprocessing.Pipe()可以创建一个管道。这个函数返回一个由两个连接对象组成的元组，这两个对象分别代表管道的两端。默认情况下，管道是双向的，每个端点都可以即读又写。\n1 2 3 from multiprocessing import Process, Pipe # 创建一个管道 parent_conn,child_conn = Pipe() 管道方法 在上面的例子中，parent_conn和child_conn都是管道对象，它们都拥有共同的方法:\nsend(obj):发送一个对象到管道的另一端。这个对象必须是可序列化的。 recv():从管道的另一端接收一个对象。该方法是阻塞的。 close():关闭管道连接。当不再需要管道时，应该调用这个方法来释放资源。 fileno():返回由连接对象使用的文件描述符。 poll(timeout):返回连接对象中是否有可以读取的数据。如果未指定timeout，会马上返回，如果timeout是一个数字，则指定了阻塞的最大秒数，如果未指定timeout，那么将一直等待。 send_bytes(buffer,offset,size):通过连接发送buffer，offset是buffer中的偏移量，size是要发送的字节数。数据以一条完整的数据发送。 recv_bytes(maxlength):以字符串的形式返回一条从连接对象另一端发送过来的字节数据。此方法在接收到数据前一直阻塞。如果连接对象被关闭或没有数据可读取，将抛出异常。如果消息长度大于maxlength，则会抛出异常且该连接对象不可再读。 recv_bytes_into(buffer,offset):将一条完整的数据读入buffer中并返回消息的字节数，此方法在接收到数据前一直阻塞。如果连接对象被关闭或没有数据可读取，将抛出异常。offset指定buffer中放置消息处的字节偏移量。如果消息长度大于buffer将抛出导常。 使用管道 管道可以在进程间传递数据。通常，一个连接会传递给一个子进程，而另一个连接保留在父进程中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from multiprocessing import Process, Pipe def child_process(conn): # 子进程从连接中接收数据 conn.send(\u0026#39;He1lo from child\u0026#39;) data =conn.recv() print(\u0026#39;Received:\u0026#39;,data) conn.close() if __name__ == \u0026#39;__main__\u0026#39;: # 创建一个管道 parent_conn, child_conn = Pipe() # 创建子进程 p = Process(target=child_process, args=(child_conn,)) p.start() # 父进程发送数据到子进程 parent_conn.send(\u0026#34;hello from parent\u0026#34;) print(\u0026#39;Received:\u0026#39;,parent_conn.recv()) #等待子进程结束 p.join() 管道特点 双向通信:管道允许两个方向的通信，即每个管道有一个接收端和一个发送端.。 点对点连接:管道通常用于两个进程之间的直接通信，不支持多个进程之间的通信。 管道大小有限:管道的缓冲区大小是有限的。如果缓冲区满了，发送操作会阻塞。 注意事项 管道默认是双向的，但也可以通过设置dup1ex=Fa1se来创建单向管道。此时返回的第一个对象只能接收消息，第二个对象只能发送消息。 当使用管道在进程间传递大量数据时，要注意管道可能会成为性能瓶颈。 1 2 3 4 5 6 7 8 9 from multiprocessing import Process, Pipe def sender(conn): conn.send([42,None,\u0026#39;Hi\u0026#39;]) conn.close() if __name__ == \u0026#34;__main__\u0026#34;: #创建一个单向管道 parent_conn, child_conn = Pipe(duplex=False) 消息队列（Queue） 消息队列提供了一种在进程间传输数据的方式，这种方式是通过在内核中维护一个消息队列来实现的。进程可以发送数据到队列，也可以从队列中接收数据。在Python的mu1tiprocessing模块中，Queue 类提供了一个先进先出(FIFO)的消息队列。\n创建消息队列 1 2 3 4 from multiprocessing import Queue #创建一个消息队列 queue = Queue(maxsize=10) # maxsize为队列中最多可以存放的元素数量 消息队列的方法 在上面的例子中，queue是创建出来的消息队列，它拥有下面几种方法:\nput(obj，block=True，timeout=None):将obi放入队列，如果可选参数block是True而且timeout是None，将会阻塞当前进程，直到有空的缓冲槽。如果timeout是正数，将会在阻塞了最多timeout秒之后还是没有可用的缓冲槽时抛出异常。如果block是False，那么在没有空的缓冲槽时，会立即抛出异常，此时timeout会被忽略。 get(b1ock=True，timeout=None):从消息队列里获取消息。该方法为阻塞等待的方法。block和timeout的作用与put一致。 empty():如果队列为空，返回True，否则返回 False。 full() :如果队列满了，返回True，否则返回 False。 qsize():返回队列中当前元素的数量。 get_nowait():立即尝试从队列里获取一个元素，如果队列为空，抛出Queue.Empty异常 put_nowait():立即尝试从队列里放入一个元素，如果队列为空，抛出Queue.Full异常 在进程中使用消息队列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from multiprocessing import Queue,Process import time def process1(process_queue): print(\u0026#34;准备接收数据\u0026#34;) print(\u0026#34;接收到的数据为：\u0026#34;,process_queue.get()) if __name__== \u0026#39;__main__\u0026#39;: process_queue = Queue(5) p1 = Process(target=process1,arg=(process_queue,)) p1.start() time.sleep(2) process_queue.put(\u0026#39;Hi\u0026#39;) p1.join() p1.close() 消息队列的特点 先进先出(FIFO):队列遵循先进先出(FIFO)的原则，即先放入队列的元素会先被取出。 同步访问:queue 类提供了一系列同步方法，如 put()、get()等，以确保多进程对队列的访问是安全的。容量限制:队列可以指定最大容量，当队列满时，新元素将无法放入;当队列空时，试图从队列中获取元素的进程将阻塞，直到有新元素放入队列。 生产者-消费者模式:Queue 类非常适合用于生产者-消费者模式，其中生产者进程将数据放入队列，而消费者进程从队列中取出数据。 共享内存 共享内存是一种进程间通信(IPC)机制，顾名思义，它允许多个进程访问同一块内存空间。每个进程都可以读取或写入这块内存，从而实现数据的共享。\n创建共享内存 在Python中，共享内存分为两种，一种是共享一个变量，一种是共享一个数组。\n在Python中，使用multiprocessing.value(type_code，*args，1ock=True)来创建一个共享变量，其中type_code表示类型代码，*args表示初始化变量的值。lock表示锁，默认会创建一个锁用来保护共享变量。如果传入False，Value的实例就不会被锁保护，它将不是进程安全的。 在Python中，使用multiprocessing.Array(type_code,size_or_initializer,1ock=True)来创建-个共享数组，其中type_code表示类型代码，size_or_initializer表示数组的大小或初始化值，如果是一个整数，则表示数组的长度，且数组将被初始化为0，如果是一组序列，则就是数组的初始化值，其长度决定数组的长度。lock表示锁，默认会创建一个锁用来保护共享数组。 类型代码 映射 描述 \u0026lsquo;b\u0026rsquo; ctypes.c_byte 有符号字节（8位） \u0026lsquo;B\u0026rsquo; ctypes.c_ubyte 无符号字节（8位） \u0026lsquo;h\u0026rsquo; ctypes.c_short 有符号短整型（16位） \u0026lsquo;H\u0026rsquo; ctypes.c_ushort 无符号短整型（16位） \u0026lsquo;i\u0026rsquo; ctypes.c_int 有符号整型（32位） \u0026lsquo;I\u0026rsquo; ctypes.c_uint 无符号整型（32位） \u0026rsquo;l' ctypes.c_long 有符号长整型（32位） \u0026lsquo;L\u0026rsquo; ctypes.c_ulong 无符号长整型（32位） \u0026lsquo;q\u0026rsquo; ctypes.c_longlong 有符号长长整型（64位） \u0026lsquo;Q\u0026rsquo; ctypes.c_ulonglong 无符号长长整型（64位） \u0026lsquo;f\u0026rsquo; ctypes.c_float 单精度浮点数（32位） \u0026rsquo;d' ctypes.c_double 双精度浮点数（64位） 共享内存的方法 value：对于value对象，其属性用于获取或设置共享变量的值 [:]‘: 对于Array对象，可以使用切片操作来获取或修改数组中的元素。 共享内存的使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from multiprocessing import Process,Value,Array def func(shared_num,shared_array): shared_num.value += 1 for i in range(len(shared_array)): shared_array[i] += 1 if __name__== \u0026#39;__main__\u0026#39;: shared_num = Value(\u0026#39;i\u0026#39;,0) shared_array = Array(\u0026#39;i\u0026#39;,range(10)) print(shared_num.value) print(shared_array[:]) p = Process(target=func,args= (shared_num,shared_array)) p.start() p.join() print(shared_num.value) print(shared_array[:]) 共享内存的特点 高效的数据共享:共享内存比其他IPC机制(如消息队列)更高效，因为它避免了数据的复制。。 同步问题:共享内存需要同步机制(如锁)来防止竞态条件 类型限制:共享内存的数据类型有限，通常只能是基本数据类型。 进程同步 在Python中，进程同步是指在多进程环境下协调各个进程对共享资源的访问，主要解决的问题是当多个进程并发访问共享资源时，如何确保任一时刻只有一个进程能够访问该资源，从而避免由于进程间的无序竞争而导致的系统资源冲突，确保系统的稳定运行。进程同步通常涉及到以下几个核心概念:\n临界资源是指一段时间内仅允许一个进程访问的资源，这可能是硬件资源，也可能是软件资源如变量、数据.表格、队列等 临界区是指访问临界资源的那部分代码。在进入临界区之前，需要检査是否可以访问临界资源，以确保资源的互斥访问。 进程同步的机制应遵循以下规则:\n空则让进:如果临界资源处于空闲状态，则进程可以进入其临界区。 忙则等待:如果临界资源正在被使用，则请求访问的进程需要等待。 常见的进程同步机制包括锁、信号量、事件、条件变量等。 锁 锁(Lock)是一种用于控制多个进程访问共享资源的机制，锁的主要目的是防止多个进程同时访问共享资源时可能产生的竞态条件(Race Condition)，确保数据的一致性和完整性。在Pvthon中，最常用的锁为互斥锁(Lock)和递归锁(RLock)\n互斥锁 这是最常见的一种锁，它确保同一时间只有一个进程可以访问共享资源。当一个进程正在使用资源时，它会锁定该资源，其他进程必须等待锁被释放后才能访问。在mu1tiprocessing模块中，Lock对象可以用来确保临界区代码的互斥执行。\n方法:\nacquire(blocking=True，timeout=-1):尝试获取锁。如果b1ocking为True 并且timeout 是默认值 -1，该方法会阻塞直到锁被获取。如果 b1ocking为 False，则立即返回而不阻塞。 release():释放锁 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import multiprocessing from multiprocessing import Queue,current_process import time #定义一个task函数，它将用于创建进程 def task(lock,queue,amount): while True: #获取一个锁 lock.acquire() # 上锁 #从队列中获取当前的余额 money = queue.get() #检查余额是否足够 if money \u0026gt;= amount: #余额足够，进行取款 money -= amount print(f\u0026#39;{current_process().name}取出{amount},现在还有{money}\u0026#39;) else: print(f\u0026#39;{current_process().name}余额不足\u0026#39;) #释放锁，允许其他进程操作 lock.release() #将跟新后的余额放回队列 queue.put(money) break queue.put(money) time.sleep(1) lock.release() if __name__ == \u0026#39;__main__\u0026#39;: count = 1000 queue = Queue(5) queue.put(count) #定义互斥锁 lock = multiprocessing.Lock() #创建两个进程 t1 = multiprocessing.Process(target=task, args=(lock,queue,50),name= \u0026#39;ZS\u0026#39;) t2 = multiprocessing.Process(target=task, args=(lock,queue,100),name= \u0026#39;LS\u0026#39;) t1.start() t2.start() t1.join() t2.join() 递归锁 递归锁与互斥锁最大的不同就是它允许同一个进程多次获取同一把锁，这意味着如果一个进程获取了锁，它还可以再次获取锁而不会导致死锁。但是该锁的内部有一个计数器，每当一个进程获取到锁时，计数器就会增加，当进程释放锁时，计数器就会减少。只有当计数器为0时，锁才会真正释放，才会允许其他的进程去获取锁，其他的使用和互斥锁一模一样。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import time from multiprocessing.dummy import current_process,Queue, RLock,Process #定义一个函数，它会不断向队列中添加数据 def producer(queue): while True: for i in range(10): queue.put(\u0026#34;HI\u0026#34;) time.sleep(1) #定义一个函数，它会不断从队列中取出数据 def consumer(queue,lock): while True: with lock: #time.sleep(2) #检查队列是否为空 if not queue.empty(): result = queue.get() print(f\u0026#39;{current_process().name}:{result}\u0026#39;) if __name__ == \u0026#39;__main__\u0026#39;: queue = Queue(10) #定义一个递归锁，保证所有内容 lock = RLock() producer1 = Process(target=producer, args=(queue,)) producer1.start() consumer1 = Process(target=consumer, args=(queue,lock,),name=\u0026#39;consumer1\u0026#39;) consumer1.start() consumer2 = Process(target=consumer, args=(queue,lock,),name=\u0026#39;consumer2\u0026#39;) consumer2.start() producer1.join() consumer1.join() consumer2.join() 信号量 信号量是一个更高级的同步机制，它内部维护任个计数器，用于控制对共享资源的最大并发访问数量。在multiprocessing模块中，semaphore对象用于此类同步，\nmultiprocessing.semaphore(value=1):创建一个信号量对象，value 参数指定了初始可用的数量，默认为1。\n信号量的方法:\nacquire([timeout=None]):尝试获取信号量。如果信号量可用，则其值减一并立即返回 True。如果信号量不可用，则阻塞直到超时或信号量变为可用。如果没有指定timeout或timeout为None，则一直等待直至信号量可用。 release():释放一个信号量，其值加一。如果信号量之前已被阻塞，则会唤醒一个正在等待的进程 事件 事件是一种简单的同步机制，允许一个进程通知一个或多个等待的进程某些事件已经发生，也就是发送一个信号而其他进程可以根据这个信号做出反应。Event对象的使用场景:\n一个进程等待另一个进程完成某项任务。 控制多个进程间的简单通信。 实现对共享资源的访问控制。 在Python中使用multiprocessing.Event 创建事件对象，其基本方法有:\nis_set():返回事件是否已设置的状态，如果被设置则返回True，否则返回 False。 set():将事件设置为真状态，即 True ，表示可以唤醒正在等待该事件的所有线程或进程。 clear():将事件设置为假状态，即 Fa1se，表示没有线程或进程会被唤醒。 wait([timeout]):阻塞当前进程直到事件被设置为真状态或超时(如果提供了timeout 参数)。 如果没有设置超时时间，则会一直等待直到事件被设置。事件的使用分为两种情况:\n事件只被唤醒一次，然后开始进行自己的工作。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 from multiprocessing import Event,Process import time from scipy.special.cython_special import powm1 def producer(start_event,): start_event.set() while True: time.sleep(1) def consumer1(start_event,): start_event.wait() while True: print(1) def consumer2(start_event,): start_event.wait() while True: print(2) def consumer3(start_event,): start_event.wait() while True: print(3) if __name__ == \u0026#39;__main__\u0026#39;: start_event = Event() p1 = Process(target=producer, args=(start_event,)) p1.start() c1 = Process(target=consumer1, args=(start_event,)) c1.start() c2 = Process(target=consumer2, args=(start_event,)) c2.start() c3 = Process(target=consumer3, args=(start_event,)) c3.start() p1.join() c1.join() c2.join() c3.join() 进程池 进程池是一组预先创建的空闲进程，它们等待执行任务，主进程负责将任务分配给进程池中的空闲进程去执行。进程池可以管理进程的创建和销毁，避免了频繁地创建和销毁进程带来的开销，通过进程池可以轻松的实现多任务的 并行处理。\n为什么使用进程池 效率:相比于手动创建和管理多个进程，使用进程池可以更高效地利用系统资源。 简化:进程池简化了并行编程的复杂性，开发者不需要关注进程的创建和销毁细节。 控制:可以限制同时运行的进程数量，防止系统资源被过度消耗。 进程池的创建 在Python中，进程池的创建有两种方式。\n使用multiprocessing库 在Python中，使用multiprocessing 模块中的Pool创建进程池:\n1 2 import multiprocessing.Pool multiprocessing.Pool(processes=None,initializer=None,initargs=(),maxtasksperchild=None) 参数解释：\nprocesses:进程池中的进程数。如果processes为None，则默认使用系统的处理器核心数。。 initializer:每个工作进程启动时要执行的可调用对象，默认为None。如果是None，则调用initializer(*initargs)。 initargs:传递给initializer的可变参数元组。 maxtasksperchild:工作进程退出之前可以完成的任务数，完成后用一个新的工作进程来替代原进程，来让闲置的资源被释放。maxtasksperchild默认是None，意味着只要Pool存在工作进程就会一直存活。 使用concurrent.futures库 在Python中，使用concurrent.futures的ProcessPoolExecutor创建进程池。\n1 2 concurrent.futures.ProcessPoolExecutor(max_workers=None, mp_context=None. initializer=None,initargs=) 参数解释：\nmax_workers:指定进程池中可以同时运行的最大进程数。如果设置为 Non列或未指定，则默认为机器的处理器数量，最多为61。 mp_context:指定多进程上下文。默认情况下，ProcessPoolExecutor 使用multiprocessing.get_context()来获取上下文。这允许你选择不同的上下文，例如 spawn、 fork.forkserver 等，这些上下文可能提供不同的功能，如更好的资源隔离、更好的安全性等。 initializer:一个可选的可调用对象，每个工作进程在启动时都会调用它。这可以用来执行进程的初始化操作，例如设置进程局部存储。 initargs:一个元组，其中包含传递给 initializer 的参数。 ","date":"2024-10-15T00:00:00Z","image":"https://UPPO8.github.io/Mybolg/images/PythonCourse/R-C.png","permalink":"https://UPPO8.github.io/Mybolg/p/python-%E5%A4%9A%E8%BF%9B%E7%A8%8B/","title":"Python-多进程"},{"content":"文件操作 文件操作的重要性 数据持久化:文件是存储数据的一种非常基本且重要的方式。通过文件，我们可以将程序运行时产生的数据永久保存下来，以便将来使用。 跨平台兼容性:文件是一种通用的数据交换格式，可以在不同的操作系统和平台上进行传输和处理。 数据备份与恢复:定期备份数据到文件有助于防止数据丢失，便于数据恢复。 数据共享:文件可以轻松地在网络之间共享，使得多人协作成为可能。I 配置管理:许多应用程序使用文件来存储配置信息，方便用户根据需要调整设置。·日志记录:文件被广泛用于记录程序运行时的日志，这对于调试和性能监控非常重要 应用场景 数据分析:读取数据文件进行数据分析，或者程序的运行结果输出到文件，以便于报告或进一步分析。 Web开发:读取配置文件来设置Web服务器的各种参数，处理用户上传的文件。 系统管理:读取和写入日志文件以监控系统状态。 文本处理:读取文本文件，进行搜索、替换等操作，并将处理后的结果保存到文件中。 游戏开发:读取账号数据、保存账号数据，管理游戏资源文件。 文件的基本概念 文件的概念 文件是一个存储在某种持久性存储介质(如硬盘、固态驱动器或磁带等)上的数据集合。文件可以包含各种类型的信息，包括文本、图像、音频、视频、应用程序代码以及其他类型的二进制数据。文件是操作系统用来组织和管理这些数据的主要方式之一。\n文件通常由以下几部分组成:\n数据:文件中存储的实际信息，即用户想要保存的具体信息，如文本、图像或代码等 元数据:关于文件本身的附加信息，包括但不限于文件名、创建日期、文件大小、文件类型等。 文件系统:这是操作系统用来组织和管理文件的一种逻辑结构，包括文件的命名、存储和检索方式。文件系统还负责管理磁盘空间的分配，并确保文件可以被正确地读写。常见的文件系统有 FAT32、NTFS 等。 文件的属性 文件名:用于标识文件的唯一名称，通常包含主文件名和扩展名(如 document.txt) 位置:文件存储在一个特定的位置，这个位置可以用目录或路径来表示。例如，在Windows系统中，文件路径可能是c:\\Documents\\example.txt;而在Unix-like系统中，路径可能是/home/user/Documents/example.txt。 文件类型:根据文件的内容和用途，文件可以有多种类型，如文本文件、图像文件、音频文件等4.文件大小:文件占用的存储空间大小，通常以字节(B)、千字节(KB)、兆字节(MB)或吉字节(GB)为单位 文件的类型 在Windows系统中，大致可以分为以下几种:\n文本文件:包含可读字符的文件，如.txt、.csv、.html等。 二进制文件:包含不可直接读的原始二进制数据的文件，如.exe、jpg、.mp3等。 可执行文件:可以被操作系统执行的文件，如.exe(Windows)。 数据文件:用于存储应用程序数据的文件，如数据库文件、配置文件等。 目录/文件夹:用于组织和管理其他文件的特殊文件。 在Linux系统中，可以分为以下几种:\n-：普通文件，比如txt、py等。 d:目录文件，比如xx目录，类比Windows中的文件夹。 b:块设备文件，Linux系统中的底层驱动文件。 c:字符设备文件，Linux系统中的底层驱动文件。 l:链接文件，类似于快捷方式 p:管道文件，用于进程间的通信。 s：套接字文件，用于网络通信的端点，用于网络传输。 文件的路径 在计算机文件系统中，路径是用来标识文件或目录位置的一种方式。路径有两种主要的形式:绝对路径和相对路径。这两种路径形式对于在文件系统中导航和访问文件非常重要。\n绝对路径 绝对路径是从文件系统的根目录开始的一条完整路径，它指明了从根目录到达目标文件或目录的具体步骤。\n特点:\n不依赖于当前工作目录。 在不同用户或程序间具有一致性 提供了文件或目录的完整位置信息。 示例:\n在Windows系统中，一个绝对路径可能看起来像这样:c:\\users\\John\\Documents\\report.txt。 在Linux/Unix系统中，一个绝对路径可能看起来像这样:/home/john/Documents/report.txt。 相对路径 相对路径是指相对于某个起始点(通常是当前工作目录)到达目标文件或目录的路径。\n特点:\n取决于当前工作目录的位置。 更加灵活，但可能会因上下文变化而变化。 适用于在同一目录层级或附近层级内的文件访问 示例:\n在Windows系统中，如果当前工作目录是c:\\users\\John\\Documents，那么我想去找同目录下的example.txt的话，就是,\\example.txt，如果上级目录下的example.txt的话，就是..\\example.txt。 在Linux/Unix中，如果当前工作目录是 /home/iohn/oocuments ，那么我想去找同目录下的example.txt的话，就是./example.txt，如果上级目录下的example.txt的话，就是../example.txt。 路径中的特殊符合 .(当前目录):表示当前目录。 ..(上一级目录):表示当前目录的父目录。 使用场景 绝对路径:当需要指定确切位置，或者在不同环境(如不同用户的系统)下保持一致时使用。\n相对路径:当文件位于同一目录或相关联的子目录中时使用，可以使程序更加灵活和便携。\n文件的操作 打开文件 在Python中，使用open()函数来打开文件，这个函数返回一个文件对象，可以用来进行后续的读写等操作。函数原型为:\n1 res = open(file_name, mode=\u0026#39;r\u0026#39;, buffering=None, encoding=None, errors=None, newline=None,closefd=True) 参数解释：\nfile_name:要打开的文件的路径加名称(包含后缀名)，可以是绝对路径也可以是相对路径。mode:打开文件的模式，默认为\u0026rsquo;r\u0026rsquo;，表示只读模式且以文本模式读取。 buffering:可选参数，缓冲区大小。0表示无缓冲，1表示行缓冲，更大的整数表示具体的缓冲区大小。默认为None，表示默认的缓冲策略，大多数情况下，使用默认值就可以了。 encoding:可选参数，用于指定文件的编码，仅适用于文本模式，默认值None表示使用系统的默认编码来打开文本文件。 errors:可选参数，用于指定如何处理编码和解码错误，对于二进制模式无效。常见的值有strict、ignore、replace等。 newline:可选参数，用于控制通用换行符模式的行为。它可以是None、\u0026rsquo;\u0026rsquo;、\u0026rsquo;\\n\u0026rsquo;、\u0026quot;\\r\u0026rsquo;或\u0026rsquo;\\r\\n\u0026rsquo;。如果设置为 None ，则通用换行符模式被启用，\\n、\\r和\\r\\n都被识别为换行符，并以\\n的形式在文本模式下读取。如果设置为其他值，则在该值处进行换行符的转换。 closefd:可选参数，如果为True(默认值)，则在文件关闭时关闭文件描述符。如果为Fa1se，则文件描述符在文件关闭时保持打开状态。 文件模式 以下是几种常见的文件打开模式:\n\u0026lsquo;r\u0026rsquo;:read 只读模式(默认值)。如果文件不存在就会触发异常, \u0026lsquo;r+\u0026rsquo;:打开文件进行读写，该文件必须存在 \u0026lsquo;w\u0026rsquo;:write 写入模式，如果文件存在则覆盖，不存在则创建。 \u0026lsquo;W+\u0026rsquo;:打开文件进行读写，如果文件存在则覆盖，如果不存在则创建。 \u0026lsquo;a\u0026rsquo;:追加模式，如果文件存在则在文件末尾追加内容，不存在则创建, \u0026lsquo;a+\u0026rsquo;:打开文件进行读写，如果文件存在则在末尾追加，如果不存在则创建。 \u0026lsquo;x\u0026rsquo;:独占创建模式，如果文件已存在则抛出异常，这可以用来避免覆盖现有文件。 \u0026lsquo;b\u0026rsquo;:二进制模式，读写时，数据不会被转换，直接以字节形式处理。 \u0026rsquo;t\u0026rsquo;:文本模式(默认值)，读写时，数据会被视为字符串。 读取文件 打开文件后，可以使用以下方法读取内容:\nread(size):size是可选参数，在文本模式下，一次最多读取文件指针后面size个大小的字符，在二进制模式下，一次最多读取文件指针后面size个大小的字节，默认size为None，表示一次性读取文件指针后面的所有内容并将其作为字符串返回。 readline():从文件中读取单行数据 readlines():读取所有行，并返回一个列表。 写入文件 要将内容写入文件，可以使用以下方法:\nwrite(str):将str的内容追加到当前文件指针位置，并将文件指针移动到新的写入位置。会返回写入的字符数量，写入其他类型的对象时，要先将它们转化为字符串或字节对象。 writelines():写入一个字符串列表。 关闭文件 在python中，使用close()方法关闭文件。关闭文件是一个重要的操作，因为它释放了与文件对象关联的系统资源，并确保数据正确地写入存储介质。 功能：\n释放资源：关闭文件，释放与文件对象关联的所有系统资源，如文件描述符、缓冲区等。 刷新缓冲区:在关闭文件之前，它会自动刷新文件的内部缓冲区，确保所有缓冲的数据都被写入磁盘, 禁止进一步操作:关闭文件后，文件对象不再允许进行读取、写入或其他操作。 重要性： 文件操作完成后，应该关闭文件以释放资源，可以使用close()方法关闭文件。在Pvthon程序中，如果不关闭打开的文件，可能会产生以下影响: 资源管理:文件描述符是有限的资源，如果不关闭文件，可能会导致资源泄漏，特别是在打开大量文件时。 数据完整性:确保所有缓冲的数据都写入磁盘，防止数据丢失。尤其是在写入操作后，如果不关闭文件，可能会导致最后写入的数据没有保存。 防止错误:关闭文件可以防止对已关闭文件的非法操作，这些操作可能会引发异常。 提高效率:关闭不再需要的文件可以释放系统资源，提高程序的整体效率。 清理操作:在关闭文件时，可以执行一些清理操作，如关闭网络连接或释放其他相关资源。 with语句 用于简化资源的打开和关闭过程，确保资源在Python中，with语句是一种上下文管理器(contextmanager)在不需要时得到适当的释放。这种机制常用于文件操作、网络连接、锁等资源的处理，可以避免资源泄露和出现其他资源管理问题。\n基本语法为:\n1 2 3 4 5 with expression [as variabfel]: with-block 例如： with open(\u0026#39;./1.txt\u0026#39;,\u0026#39;w\u0026#39;) as fd: res = fd.write() 表达式(expression):这个表达式必须返回一个实现了上下文管理器协议的对象，也就是说，它需要包含enter_和_exit_两个方法。 as 子句:这是可选的。如果提供了as子句，那么expression中_enter_方法的返回值将被赋值给变量。 with-b1ock:这个代码块是 with语句的主体，在执行这个代码块之前，会首先调用上下文管理器的_enter_方法。当with-b1ock执行完毕后，不论是因为正常完成还是因为异常，都会调用上下文管理器的exit 方法，该方法负青关闭文件 文件指针的操作 获取文件指针的位置 在python中，使用tell()函数去返回当前文件指针的位置.\n1 tell() tell()函数没有参数，它的功能就是返回文件指针当前位置相对于文件开头的偏移量。这个偏移量是一个整数，表示从文件开头到当前读取位置的字节数。\n注意事项:\ntell()方法仅在文件被打开用于读取时才有意义，因为在写入模式下，文件指针的位置会随着写入操作而改变 在读取模式下，tell()方法返回的是当前读取位置相对于文件开头的偏移量。 其返回值是字节数，不是字符数，对于utf-8的编码格式来说，一个汉字占三个字节，所以读取中文时，字符数与字节数是不一样的。 改变文件指针的位置 在python中，使用seek()函数去改变文件指针的位置。\n1 seek(offset,whence=0) 其中: offset:表示相对于whence的偏移量，是一个整数。这个偏移量可以是正数，也可以是负数。正数表示向文件末尾方向移动，负数表示向文件开头方向移动，0则表示不偏移。\nwhence:是一个可选的参数，默认为0。它指定了offset的起始位置，可以是以下三个值之一\n0:表示从文件开头开始计算偏移量(默认值) 1:表示从当前文件指针位置开始计算偏移量。 2:表示从文件末尾开始计算偏移量。 注意事项:\nseek 方法在文本模式和二进制模式下都有效，但文本模式whence只能使用默认值，不能自己修改。 seek 方法基于字节偏移量。这意味着即使文件包含多字节字符，seek 改变的仍然是字节偏移量。 1 2 3 4 5 6 7 8 9 10 11 12 import os from io import TextIOWrapper path =\u0026#39;./1.txt\u0026#39; with open(\u0026#39;./1.txt\u0026#39;,\u0026#39;a+\u0026#39;) as fd: res = fd.tell() ret = fd.read() print(ret) fd.seek(0) ret1 = fd.read() print(ret1) 获取文件属性 在Python中，可以使用内置的os模块来获取文件的属性。以下是一些常用的方法来获取文件属性:\n获取文件大小 在python中，使用**os.path.getsize()**获取指定文件的大小(以字节为单位)\nos.path.getsize(path) path(字符串)-文件的路径。\n返回一个整数，表示文件的大小(以字节为单位)。如果文件不存在或无法访问，会抛出异常。\n获取文件的最后修改时间 在python中，使用**os.path.getmtime()**获取指定文件的最后修改时间。\nos.path.getmtime(path) path(字符串)-文件的路径。\n获取文件的创建时间 在python中，使用**os.path.getctime()**获取指定文件的创建时间。\nos.path.getctime(path) path(字符串)-文件的路径。\n获取文件的最后访问时间 在python中，使用**os.path.getatime()**获取指定文件的最后访问时间。\nos.path.getatime(path) path(字符串)-文件的路径\n目录操作 在Python中，可以使用多个模块来操作目录，但是最常用的就是os模块，以下就是一些常见的目录操作:\n创建目录 在Python中使用os.mkdir(path)函数来创建目录。\n1 2 import os os.mkdir(path, mode=0o777) 其中：\npath(字符串)-要创建的目录的路径。 mode (整型，可选)-设置新创建目录的权限位。默认值是 0o777(八进制表示)，意味着所有人都有读、写和执行权限，只针对Linux系统，Windows系统会忽略。 如果目录创建成功，则函数不返回任何内容。如果指定的路径已经存在就会抛出异常，如果路径是无效的，或者由于权限不足等原因无法创建目录，也会抛出异常。\n注意事项：\nos.mkdir 只能创建一级目录，如果父目录不存在，则会抛出异常。 如果需要创建多级目录结构，可以使用os.makedirs函数，它会递归地创建所需的中间目录。 删除目录 在Python中使用os.rmdir(path)函数去删除目录。\n1 2 import os os.rmdir(path) path(字符串)-要删除的空目录的路径。\n如果目录删除成功，则函数不返回任何内容。如果指定的路径不存在，则会抛出异常，如果路径不是一个空目录,或者由于权限不足等原因无法删除目录，也会抛出此异常。\n注意事项 os.rmdir 只能删除空目录。如果目录中包含文件或其他目录，os.rmdir 将无法删除它，并且会抛出异常。\n改变当前工作目录 在Python中使用os.chdir(path)函数来改变工作目录\n1 2 import os os.chdir(path) path(字符串)-要切换到的目录的路径。如果指定的路径不存在、指定的路径不是一个目录、没有权限更改到指定的目录就会抛出异常。\n如果目录切换成功，则函数不返回任何内容\n获取当前工作目录 在Python中使用os.getcwd()函数获取当前的工作目录\n1 os.getcwd() 该函数没有参数，但会返回一个字符串，表示当前工作目录。\n列出自录下的所有内容 在Python中使用os.listdir(path)函数获取指定目录下的所有文件和子目录的名称。\n1 2 import os items =os.listdir(path) path(字符串)-要列出内容的目录的路径。如果省略，默认为当前工作目录。如果指定的路径不存在、指定的路径不是一个目录、没有权限读取指定的目录就会抛出异常。\n这个函数返回一个列表，其中包含指定路径下的所有文件和子目录的名称。\n注意事项\nos.1istdir 不会递归地列出子目录中的内容。它只列出直接位于指定目录下的文件和子目录。 返回的列表中只包含名称，不包含路径。如果需要完整路径，你需要将目录名称与路径结合起来。 如果目录为空，返回的列表将是空的。 在使用 os.1istdir 时，应该考虑到可能出现的异常，并适当处理它们，以确保代码的健壮性， 重命名目录 在Python中使用os.rename(src，dst)函数对一个文件或目录进行重命名。这个函数可以将一个文件或目录从其当前路径(源路径)更改为一个新的路径(目标路径)。\n1 2 import os os.rename(src,dst) 参数解释\nsrc(字符串)-要重命名的文件或目录的当前路径， dst(字符串)-文件或目录的新名称和路径。如果重命名成功，则函数不返回任何内容。 检查路径是否为目录 在Python中使用os.path.isdir()函数检查给定的路径是否是一个目录。\n1 2 import os.path is_directory=os.path.isdir(path) 参数解释：\npath(字符串)-要检查的路径,如果指定的路径是一个目录，返回 True;否则返回 Fa1se\n路径拼接 在Python中使用**os.path.join(path,*path)**函数将一个或多个路径组件合并成一个完整的路径!这个函数会根据操作系统的文件系统约定来正确地处理路径分隔符。\nimport os os.path.join(path,*paths) 参数解释：\npath(字符串)-起始路径，通常是一个目录路径, *paths(可变参数)-需要连接到 path 的其他路径片段。返回一个字符串，表示将所有路径片段连接后的完整路径。 os.path.join()的作用包括:\n合并路径:将多个路径组件合并成一个单一的路径字符串, 处理分隔符:它会根据操作系统自动添加或删除路径分隔符(例如，在 Windows 上是反斜杠\\，在Unix/Linux 上是正斜杠 /)。 消除冗余分隔符:如果路径组件之间有多余的分隔符，os.path,join() 会自动处理，避免产生错误的路径. 使用os.path.join()的好处是，它能够确保生成的路径在不同的操作系统上是正确的，从而提高了代码的可移植性。此外，它还能避免手动拼接路径时可能出现的错误，如忘记添加分隔符或添加了错误的分隔符。\n路径拆分 在Python中使用os.path.split(path)函数将路径分割成两部分:目录路径和文件名。\n1 2 import os head, tail = os.path.split(path) 参数解释：\npath:表示要分割的路径， head:它是 path 的目录路径 tai1:它是 path 的文件名 os.path.split()的主要用途包括:\n从完整路径中提取文件名或目录名。 用于文件处理时，需要单独操作文件名和路径的其他部分。 在遍历文件系统时，帮助确定每个文件的上级目录。 需要注意的是，如果提供的路径以路径分隔符结尾，那么 tai1 将是一个空字符串，表示路径的最后一部分是一个目录。此外，如果路径是空字符串，os.path.split()将返回两个空字符串。\n","date":"2024-10-14T00:00:00Z","image":"https://UPPO8.github.io/Mybolg/images/PythonCourse/R-C.png","permalink":"https://UPPO8.github.io/Mybolg/p/python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","title":"Python文件操作"},{"content":"正则表达式 正则表达式，又称规则表达式，(Regular Expression，在代码中常简写为regex、regexp或RE)，是一种文体模式，包括普通字符(例如，a到z之间的字母)和特殊字符(称为\u0026quot;元字符\u0026quot;)。正则表达式使用单个字符串来描述。匹配一系列符合某个句法规则的字符串，通常被用来检索、替换那些符合某个模式(规则)的文本。通俗的说，正则表达式就是一种语法规则，用来匹配文本中的文本。\nre.match 该函数尝试从字符串的起始位置匹配，如果起始位置没有匹配成功的话，就返回None，否则会返回一个匹配对象，匹配对象的方法可参考下面的表格。\n方法 说明 group() 返回被匹配的字符串 start() 返回匹配开始的位置 ecd() 返回匹配结束的位置 span() 返回一个元组包含开始和结束的位置 函数原型:\nre.match(pattern，string，flags=0) 其中： pattern:正则表达式的格式。 string:被匹配的文本。 flags(可选):标志位，用于控制正则表达式的匹配方式， 如:是否区分大小写、设置多行匹配模式等，具体有哪些标志可参考下面的附录1表格。 常用的应用场景有:\n验证输入格式:检查用户输入是否符合特定的格式，例如电子邮件、电话号码、日期等 提取信息:从字符串的开始位置提取符合正则表达式模式的字串，如提取文件名等。 数据解析:在处理日志文件或配置文件时，可以用来解析每行的开始部分，获取关键信息。 1 2 3 4 5 6 7 8 9 10 11 import re while True: email = input(\u0026#39;请输入有效的邮箱:\u0026#39;) pattern =r\u0026#34;[0-9a-zA-Z+-_.]+@[0-9a-zA-Z.-]+\\.[a-zA-Z]{2,}\u0026#34; #匹配【0-9，a-z，A-Z，+ - _ .至少一次】，【@符号】，【匹配0-9，a-z，A-Z，- . 至少一次】，【符号.】，【a-z，A-Z两次以上】 res =re.match(pattern,email) if res: print(\u0026#39;您的邮箱格式正确\u0026#39;) break else: print(\u0026#39;您的邮箱格式有误，请重新输入\u0026#39;) re.search 该函数从文本中获取第一个符合正则表达式模式的字符的位置，并返回一个匹配对象，如果没有匹配到，就返回None.\n函数原型:\nre.search(pattern，string,flags=0) 其中： pattern:正则表达式的格式。 string:被匹配的文本。 flags(可选):标志位，用于控制正则表达式的匹配方式， 如:是否区分大小写、设置多行匹配模式等，具体有哪些标志可参考下面表格。 flags参数 说明 re.I 忽略字母大小写 re.L 影响 “w, “W, “b, 和 “B，这取决于当前的本地化设置。 re.M 多行匹配，使^和\u0026amp;能够匹配每一行的行首和行尾 re.S 单行匹配，使.特殊字符能匹配任何字符，包括换行符 re.X 允许你编写更易于阅读的正则表达式，忽略空白字符和注释 常用的应用场景有:\n检查字符串是否包含子串:检査一个字符串是否包含某个特定的文本。 提取数据:从字符串中的任意位置提取信息，例如从一个文本段落中提取所有提到的日期。 搜索文件:在某文件中查找特定的消息或事件。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import re text =\u0026#39;\u0026#39;\u0026#39; gjiaokremgn vkn24124pa2 13315561889 hbvuijrbnio 15633567985 \u0026#39;\u0026#39;\u0026#39; pattern =r\u0026#39;^[1]{1}[3589]{1}[0-9]{9}$\u0026#39; res =re.search(pattern,text，re.M) if res: print(res.group()) print(res.start()) re.findall 该函数从文本中寻找所有与模式匹配的子串，并将所有的匹配结果存储到一个列表中进行返回，如果没有匹配成功会返回一个空列表。\n函数原型:\nre.findall(pattern，string，flags=0) 其中： pattern:正则表达式的格式。 string:被匹配的文本。 flags(可选):标志位，用于控制正则表达式的匹配方式， 如:是否区分大小写、设置多行匹配模式等，具体有哪些标志可参考上面的表格flags参数。 常用的应用场景有:\n提取多个子串:当你需要在字符串中找到所有匹配特定模式的字串时, 文本分析:在文本中，提取文本中特定的词汇、短语或模式。 1 2 3 4 5 6 7 8 9 10 11 12 import re text =\u0026#39;\u0026#39;\u0026#39; gjiaokremgn vkn24124pa2 13315561889 hbvuijrbnio 15633567985 \u0026#39;\u0026#39;\u0026#39; pattern =r\u0026#39;^[1]{1}[3589]{1}[0-9]{9}$\u0026#39; res =re.findall(pattern,text，re.M) print(res) re.sub 该函数的作用就是将文本中与模式匹配的部分替换为其他的内容。\n函数原型:\nre.sub(pattern,repl,string,count，flags=0) 其中： pattern:正则表达式的格式。 repl:这是替换文本或一个函数。如果是文本，就是将匹配到的内容替换为该文本;如果是函数，会在函数中进行文本处理的操作。 string:被匹配的文本。 count(可选):这是可选参数，表示替换的最大次数。默认值为0，表示替换所有匹配项。 flags(可选):标志位，用于控制正则表达式的匹配方式， 如:是否区分大小写、设置多行匹配模式等，具体有哪些标志可参考下面的附录1表格。 常用的应用场景有:\n文本格式化:将文本中的特定模式的文本替换为另一种格式。 数据清洗:在处理数据时，移除或替换无效或不需要的字符，比如在一系列文本中删除非数字字符以清理电话号码。 敏感信息脱敏:在显示或存储数据前，将敏感信息(比如身份证号、手机号)的部分内容替换为星号 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import re #原始字符串 text =\u0026#34;Hello 123 World 456\u0026#34; #定义一个正则表达式模式，匹配数字\\d pattern =r\u0026#39;d+\u0026#39; #定义一个替换函数 def replace(match): #将匹配到的数字乘以2 number = int(match.group()) return str(number*2) #使用re.sub 和替换函数 new_text =re,sub(pattern, replace, text) print(new_text) #输出\u0026#34;Hello 246 World 91 re.split 该函数的作用就是将某文本根据匹配模式进行分割，并将分割后的结果放入列表中返回。\n函数原型:\nre.split(pattern,string,maxsplit，flags=0) 其中： pattern:正则表达式的格式, string:被匹配的文本。 maxsplit(可选):这是可选参数，表示最大分割次数。默认值为0，表示分割所有匹配项。 flags(可选):标志位，用于控制正则表达式的匹配方式， 如:是否区分大小写、设置多行匹配模式等，具体有哪些标志可参考上面的表格。 1 2 3 4 5 6 import re text = \u0026#39;apple, banana, orange, watermelon\u0026#39; fruits = re.split(r\u0026#39;,\\s*\u0026#39;,text) #匹配，\\s 匹配空白符，*匹配0次或多次 print(fruits) re.compile 该函数会预先编译正则表达式要匹配的模式，并会返回一个正则表达式的对象，该对象与re.match返回的对象不同，该对象可以调用上面的函数。\n函数原型:\nre.compile(pattern,flags=0) 其中： pattern:要匹配的正则表达式。 flags(可选):标志位，用于控制正则表达式的匹配方式， 如:是否区分大小写、设置多行匹配模式等，具体有哪些标志可参考上面的表格。 常见的应用场景: 多次匹配:当你需要在一个较长的文本中多次应用同一个正则表达式时，使用re.compile可以避免每次匹配时都重新编译表达式。\n装饰器 在Python中，装饰器(Decorator)本质上是一种特殊的嵌套函数，它接收一个函数作为参数(该函数就是被装饰的函数)，并返回一个新的函数(装饰之后的函数)。\n装饰器最大的作用就是可以让我们在不改变被装饰函数的代码的情况下去给它添加新的功能\n装饰器的基本用法 在不改变原有func()的情况下，使用装饰器给func()函数添加打印b，c的功能。\n1 2 3 4 5 6 7 8 9 10 11 12 def decorator(f): def f1(): print(\u0026#39;b\u0026#39;) f() print(\u0026#39;c\u0026#39;) return f1 def func(): print(\u0026#39;a\u0026#39;) func = decorator(func) #可以替换为@decorator func() ","date":"2024-10-13T00:00:00Z","image":"https://UPPO8.github.io/Mybolg/images/PythonCourse/R-C.png","permalink":"https://UPPO8.github.io/Mybolg/p/python%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","title":"Python的正则表达式"},{"content":"模块与包 模块的概念 模块就是一个包含了Python代码的.py为后缀的Python文件，可以被其他Python程序导入和使用，也可以自己独立执行，里面存放着一组相关的函数或者类，比如产看关键字列表时导入的keyword模块。\n模块的导入有以下几种形式：\nimport 模块 import 模块 as 别名 from 模块 import 模块 from 模块 import * from 模块 import 模块 as 别名 使用import直接导入\n1 2 3 4 5 6 #moduleA def add(x,y): return x + y a = 1 b = 2 调用模块A的方式为：moduleA.add( )\n1 2 3 4 #moduleB import moduleA ret = module.add(4,9) print(ret) 模块的作用：\n令Python代码的编写不必从零开始。 避免了同一模块内命名重复问题。 方便代码的管理与维护，提高代码的维护性。 包的概念 包就是一个有层次的文件目录结构，用来跟好的组织和管理模块。通俗的说就是一个目录，里面存放Python文件和新的包目录，并且每一个包都需要存在一个__init__.py文件。\ninit.py文件的主要作用：\n标识包目录 执行初始化代码 控制包的导入行为：通过__all__ 来控制那些模块可以被导入，防止不需要的模块导入。 提供包级别的命名空间 批量导入模块 第三方包的相关操作：\n安装包\npip install package-name == version 更新包\npip install -upgrade package-name == version 卸载包\npip uninstall package-name 异常处理机制 异常是一个事件，会在程序执行过程中产生，并且会影响程序的正常执行。\n一般情况下，Python遇见错误的代码或者无法处理正常程序就会产生一个异常，异常被抛出后，捕捉程序会按照某种机制继续运行，如果对抛出的异常不做任何处理，程序就会终止运行。\n常见的异常有：\nKeyboardInterrupt：用户主动结束程序 AttributeError：尝试访问对象没有的属性 TypeError：操作非法类型的数据 IndexError：序列中没有索引 KeyError：字典中没有键 Exception：通用的异常类，用于捕获其他说有的异常情况 在Python中，使用try、except、finally、else关键字来组合成不同方式，其中try和except时异常处理机制的核心。\n异常处理分三种，捕获单个异常、捕获多个异常和捕获全部异常，在捕获dao对应的异常后，不会再导致程序终止执行，而是会执行处理异常的代码。\n异常捕获格式：\n1 2 3 4 5 6 7 8 9 10 try： #有可能发生异常的代码 except 某个异常： #某个异常可以用（异常1，异常2）表示捕获多个异常 #也可以用替换为Exception，捕获所有异常 #异常发生后要执行的代码 else： #如果没有异常发生，在try执行完毕后执行这里的代码 finally： #不管有没有捕获到异常，最后都会执行这里的代码 自定义异常 在Python中使用raise关键字手动抛出异常，使用方法：\nraise Exception(arg) Exception用于指定要抛出的异常类型，该类型来自Python解释器自带的异常类型。 agr是一个可选参数，用于提供关于异常的信息。 例如： 1 2 3 4 for i in range(100): print(i) print(a) raise NameError(\u0026#39;未定义变量\u0026#39;) 自定义异常，在Python中，自定义属于自己的异常必须继承Exception类，其格式：\n1 2 3 4 5 6 7 8 9 10 11 class MyException(Exception): def __init__(message, code, traceback): self.code = code self.traceback =traceback #使用自定义异常 try： raise MyException(message:\u0026#34;\u0026#34;,code = 404 , traceback = None) except MyException as e: print(f\u0026#39;捕获到自定义异常：{e}\u0026#39;) print(f\u0026#39;错误代码：{e.code}\u0026#39;) print(f\u0026#39;追踪信息：{e.traceback}\u0026#39;) 在Python中记录日志文件，记录日志使用logging库，日志的级别从高到底为：\nCritical:系统崩溃级别的错误 error：运行时的错误，可能导致程序无法运行 warning：警告消息 info：信息性消息，程序正常运行 debug：详细信息，通常在诊断问题时有用 1 2 3 4 5 6 7 8 9 import logging #设置日志打印到指定路径，日志打印级别 logging.basicConfig(filename= \u0026#39;./app.log\u0026#39;，level= logging.debug,format = \u0026#39;%(name)s - %(levelname)s - %(asctime)s - %(message)s\u0026#39;) #format = \u0026#39;%(name)s - %(levelname)s - %(asctime)s - %(message)s\u0026#39; logging.critical(\u0026#39;程序崩溃\u0026#39;) logging.error(\u0026#39;程序出错\u0026#39;) logging.warning(\u0026#39;警告\u0026#39;) logging.info(\u0026#39;正常运行\u0026#39;) logging.debug(\u0026#39;调试运行\u0026#39;) 迭代器 迭代器(iterator)是一个实现了迭代器协议的对象。迭代器协议指的是对象需要实现两个方法:\n__iter__方法:当迭代器被创建时，这个方法会被调用，并且应该返回迭代器对象本身。这个方法使得对象能 够被用在for循环以及其他需要送代器的上下文中。 __next__方法:这个方法会在每次迭代中被调用，并且返回序列中的下一个元素。如果所有的元素都已经迭代完毕，会抛出一个Stopiteration类型的异常，表示迭代已经完成。 可迭代对象 可迭代对象(Iterable)是指能够返回一个迭代器的对象，换句话说，可迭代对象是实现了__iter__方法的对象，具有以下特点:\n实现了__iter__ 方法:可迭代对象必须拥有该方法，以便于返回一个迭代器对象。 可以用于for循环: 可迭代对象可以用于for循环，在for循环时，Python会自动调用__iter__方法来获取迭代器，然后不断调用迭代器的__next__去获取下一个元素。 Python中内置的列表、元组、字符串等都是可迭代对象，在使用for循环去遍历时，会调用可迭代对象的__iter__方法来获取一个迭代器，接着不断调用迭代器的__next__方法去获取下一个元素，直到元素全部迭代完毕，抛出异常，for循环会自己捕获这个异常并退出循环，从而完成一次for循环。\n迭代器与可迭代对象的关系： 所有迭代器都是可迭代对象:因为迭代器都必须具有__iter__和__next__方法，并且通常返回自身，也可以去访问序列中的下一个元素，并在所有元素都被迭代后抛出Stoplteration异常。 不是所有可迭代对象都是迭代器:可迭代对象只实现__iter__ 方法，并不实现__next__方法。比如Python内置的列表、元组、字符串等虽然是可迭代对象，但不是迭代器。 简单来说就是：1.凡是可作用for循环的对象都是可迭代对象；2.凡是同时拥有__iter__和__next__方法的都是迭代器。\n使用迭代器遍历列表 比如下列使用迭代器 __next__方法来遍历列表\n1 2 3 4 5 6 7 8 9 ls1 = [1,2,3,4,5,6] ls1_iter = ls1.__iter__() try: while True: item = ls1_iter.__next__() print(item) except StopIteration: print(\u0026#34;遍历完成\u0026#34;) 生成器 生成器(Generator)是一种特殊的迭代器，它可以在需要时动态生成值,避免一次性生成所有值所占用的大量内存。生成器使用 yield语句来产生值，可以通过迭代器协议来逐个获取生成器产生的值。生成器可以在循环中被逐个迭代，从而实现高效地处理大量数据或者无限序列。在Python中，生成器可以通过函数定义和生成器表达式来创建。\n生成器的特点 生成器的主要特点包括:\n惰性求值:生成器不会在创建时生成所有值，而是逐个生成值。这意味着生成器可以在需要的时候再去生成值, 使用yield关键字:只有yield被调用时，生成器才会返回一个值，并且程序暂停执行，直到下一次迭代时才继续执行。 内存效率:生成器可以处理大型数据集或生成大型数据结构，而不会占用太多内存，因为它们只在需要时生成值。 迭代器协议:生成器也是迭代器，所有实现了迭代器协议，因此可以用于for循环和其他需要迭代器的代码中。 生成器函数 生成器使用最多的地方是和函数结合，因此，拥有生成器的函数就叫做生成器函数，也可以理解为函数中包含了vield关键字的函数就是一个生成器函数。生成器函数包含如下特点:\n使用yield关键字:普通函数使用return返回值，而生成器函数使用yield关键字返回值。 状态保持:生成器函数在每次产生一个值之后会暂停执行，并保持当前的状态，包括局部变量的状态和当前的执行位置。当再次调用 生成器时，他会从上次yield语句之后的地方继续执行。 惰性求值:生成器只在需要时才计算并生成值，这意味着它可以高效处理大量数据或无限流数据, 生成器函数在调用时，不会立即执行函数里面的代码，而是会先返回一个生成器的对象，当调用生成器对象的__next__方法时，才会进入函数中并执行函数里面的代码，遇到yield关键字后，函数的执行将会暂停，并将yield后面的表达式作为当前迭代的值返回。然后每次调用生成器的__next__方法或使用for循环进行迭代时，函数会从上次暂停的地方继续执行，直到再次遇到yield关键字，并再次返回一个值，直到无法继续生成为止。\n","date":"2024-10-11T00:00:00Z","image":"https://UPPO8.github.io/Mybolg/images/PythonCourse/R-C.png","permalink":"https://UPPO8.github.io/Mybolg/p/python%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/","title":"Python模块与异常处理机制"},{"content":"面向过程和面向对象 面向过程【POP】是一种以过程为中心的编程思想，将程序看作一系列的命令，函数或过程的集合，主要是解决问的步骤和过程。程序被划分为一系列的函数，每个函数扶着完成一个特定的任务。数据在整个程序都是自由流动的，任何函数都可以访问和修改数据。\n面向对象编程【OOP】是将程序看作一系列对象的集合，每个对象都是独立 的个体，包含数据和操作这些数据的方法。这些对象之间通过发送消息来相互共同解决某种问题。\n面向过程：\n优点：效率高，性能高效。\n缺点：耦合度高，扩展性差，不易维护。\n面向对象：\n优点：模块化，扩展性强，易维护，代码重复性高。\n缺点：效率比面向过程低，学习难度大，性能开销大。\n类的定义 在Python中，使用class关键字定义一个类。定义格式为：\n1 2 class MyClass: pass 类的调用，也称为类的实例化，实例化出来的内容就称为对象，也叫创建对象。\n创建对象的格式为：\n对象名 = 类名（） 对象与类之间的关系：\n对象拥有类所定义的全部的属性和行为。 对象的属性和行为可以单独进行增加、修改、删除。 对象不能单独创建，必须依托类的实例化，且一个类可以实例化无数的对象。 对象之间的属性和行为不是共享的。 self参数 self是一个参数，表示对象自身，里面存放着对象自身的地址。如果希望类中的方法可以被对象调用，那么第一个参数必须是self。作用就是将实例对象与类的方法进行绑定，这样才能让每个对象都能调用属于自己的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class MyClass: name = \u0026#39;zhangsan\u0026#39; height = 180 def func(self): print(f\u0026#39;我是：{self.name}\u0026#39;) #创建对象 example1 = MyClass() #通过对象去调用属性， example1.func() #修改类中的属性 example1.name = \u0026#39;lisi\u0026#39; print(example1.name) #添加一个属性 examlpe1.age = 18 print(example1.age) #对类中的函数的添加和修改 def func(self): print(f\u0026#39;我的身高是{self.height}\u0026#39;) from types import MethodType example1.func = MethodType(func,example1) example1.func() 构造函数与析构函数 构造函数__init__():\n在创建对象时自动调用的一种函数，用来进行初始化属性，不是必须要定义的，可以在需要的时候再定义。\n析构函数__del__():\n在对象的引用清理时会自动调用的一种函数，一般用来进行释放资源的操作。在Python有自动回收内存机制，不推荐使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #构造函数示例 class Person: def __init__(self,name,age): self.name = name self.age = age def say(self): print(f\u0026#39;我是{self.name}，今年{self.age}岁了\u0026#39;) person1 = Person(\u0026#39;zhangsan\u0026#39;,18) person2 = Person(\u0026#39;lisi\u0026#39;,55) print(person1.name) print(person2.age) person1.say() person2.say() 类的封装 在Python中可以通过给属性名和方法名添加下划线（_）设置权限，根据下划线的个数分为不同类型：\n单下划线前缀：表示该属性或方法是内部使用，事实上程序是可访问的。 双下划线前缀：设置私有权限的方法，将该属性或行为定义为私有，且不可被对象访问。 双下划线前后缀：表示Python中的特殊的属性或方法，有特殊的意义和用途，不推荐自定义。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #私有权限设置 class Person: def __init__(self,name,password): self.name = name self.phone_id= \u0026#39;1234567890\u0026#39; self.__password = None #设置一个私有属性 def __say(self): print(f\u0026#34;我的密码是{self.__password}\u0026#34;) def change_password(self): self.__password = \u0026#34;4567898\u0026#34; self.__say() p1 = Person(\u0026#39;zhangsan\u0026#39;,\u0026#39;123456\u0026#39;) print(p1.name) print(p1.phone_id) p1.change_password() 类的继承 在Python中，一个类可以被继承，也可以去继承别的类，其中类的关系为父类与子类。在继承过程中，子类会继承父类的所有属性和行为，并且一个子类可以有多个父类。\n表示格式为：\nclass Person(要继承的类): pass 当不写【要继承的类】时，Python3.x中默认继承object类。object类中有以下函数：\n名称 作用 new() 创建对象 init() 初始化对象 eq() 定义比较符 iter() 让对象支持迭代 next() 在迭代中返回下一个值 class 对象所属的类 doc 对象的文档字符串 name 类的名称 类的多继承中，可以继承多个父类，但是也可能导致冲突，比如子类和多个父类有相同的属性和方法。那么此时在使用该属性或方法，其顺序为：\n子类》从左到右第一个父类》第二个父类》... 对于复杂的继承关系，使用子类的mro( )方法获取继承顺序。\n1 2 3 4 5 6 7 8 9 10 11 12 #单继承 class Zhangsan: name = \u0026#39;zhangsan\u0026#39; height = 180 def func(self): print(f\u0026#39;我是：{self.name}\u0026#39;) class Lisi(Zhangsan): pass p1 = Lisi() p1.func() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #多继承 class A: def __init__(self): print(\u0026#34;A\u0026#34;) class B1(A): def __init__(self): A.__init__(self) print(\u0026#34;B1\u0026#34;) class B2(A): def __init__(self): A.__init__(self) print(\u0026#34;B2\u0026#34;) class C(B1,B2): def __init__(self): B1.__init__(self) B2.__init__(self) print(\u0026#34;C\u0026#34;) c = C() #打印结果 A B1 A B2 C 这里的打印结果中，出现了两次A，如何避免这种资源浪费？\n答案是：使用super() 函数，根据mro继承顺序去搜索父类中的指定函数，并且自动绑定self参数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #多继承，使用super()函数 class A: def __init__(self): print(\u0026#34;A\u0026#34;) class B1(A): def __init__(self): super().__init__() print(\u0026#34;B1\u0026#34;) class B2(A): def __init__(self): super().__init__() print(\u0026#34;B2\u0026#34;) class C(B1,B2): def __init__(self): super().__init__() print(\u0026#34;C\u0026#34;) c = C() #打印结果 A B2 B1 C 类的多态 多态指允许不同对象对同一个方法卓出不同响应，即同一个方法可以根据不同对象的类型而表现出不同行为。\n比如len()函数，对于字符串来说是统计字符串的长度，对于列表是统计列表中元素的个数。\n在类的继承中所用到的方法重写，就是一种实现多态的方式。通过重写父类中的属性和方法，使其拥有自己独特的属性和方法。\n","date":"2024-10-10T00:00:00Z","image":"https://UPPO8.github.io/Mybolg/images/PythonCourse/R-C.png","permalink":"https://UPPO8.github.io/Mybolg/p/python%E7%9A%84%E7%B1%BB/","title":"Python的类"},{"content":"函数的概念 函数：具有独立功能的代码块，使用函数名封装，通过函数名进行调用。其出现的目的就是为了代码的重复使用。\nPython中的函数分为两类：\n内置函数：在Python内部封装好的函数，比如前面用到的print()、input()等。\n自定义函数：用户在Python的语法规则下自己创建的具有独特功能的函数。\n常用的一些【内置函数】如：\n函数名 描述 min() max() 获取最大值最小值 help() 获取说明文档，使用示例help(min) abs() 求绝对值，可直接打印绝对值 round() 四舍五入，可按要求保留位数 pow(x,y) 求x的y次幂 自定义函数以def 关键字开头，后街函数名和():()中的参数需要定义，使用return结束函数，可选择返回一个值。如下列一个例子：\n1 2 3 def add(x,y): z = x +y return z 自定义函数需要关注，主要有名称、功能、参数、返回值。\n函数的参数 参数：\n参数是在函数定义时圆括号内的变量，用于接收调用函数时外部传递进来的数据。参数的最大作用就是可以让函数能够在不同的情况下重复使用。\n形式参数：也叫做形参，是函数定义中的参数，用于接收调用函数时传递的数据。形式参数在函数定义时被声明，并且在函数体内被用来执行相应的操作。\n实际参数：也称为参数值或者实参，是在函数调用时提供给函数的具体数值或变量。实际参数是根据函数定义中形式参数的顺序或者参数名对应传递给函数的数据。\n参数传入有5种方法：\n位置参数：参数传递时实参的顺序和个数必须和形参保持一致 1 2 3 4 def sub(x,y): print(x - y) sub(2,1) 关键字参数：使用【形参名字=实参】的方式,不用考虑形参的位置 1 2 3 4 def sub(x,y): print(x - y) sub(y=1,x=2) 默认参数：默认在定义时，必须放在形参的最右边 1 2 3 4 5 6 def add(x,y=2,z=1): print(\u0026#34;x的值为：\u0026#34;,x) print(\u0026#34;y的值为：\u0026#34;,y) print(\u0026#34;z的值为：\u0026#34;,z) add(1,y=3,z=5) 位置不定长参数：在函数定义时，使用*args来表示 1 2 3 4 5 6 7 8 def func(*args): for i in args: print(i) print(len(args)) print(type(args)) print(args) func(1,2,3,\u0026#39;abd\u0026#39;) 关键字不定长参数：以**kwargs作为标志，它会将输入的关键字参数中的关键字作为键值对的建，将关键字参数中的实参作为键值对的值。 1 2 3 4 5 def func(**kwargs): print(kwargs) print(type(kwargs)) func(name = \u0026#34;lisi\u0026#34;,age = 55) 函数的返回值 如果函数的运行结果需要在其他函数中使用，那么这个函数就应该被定义为带返回值的函数。\n函数的运行结果使用return关键字进行返回。\nreturn可以出现在函数的任意位置用于结束函数，但是一般放在函数的最后面以保证代码块能正常运行完毕。\n返回值可以是一个值，或多个值，如果返回的值是多个结果，默认为元组类型。\n1 2 3 4 5 6 7 8 def sub(x,y): z = x - y #将计算结果返回 return z #也可以 return x-y #定义一个变量ret接受返回值 ret = sub(2,1) print(ret) 局部变量和全局变量 变量的作用域是指变量生效的范围，根据范围作用的大小可分为局部变量和全局变量。\n1 2 3 a = 1 #全局变量 def : b = 2 #局部变量 局部变量：在函数定义时用到的参数和函数内部定义的变量。\n作用域：仅作用在函数内部，函数执行完毕，局部变量销毁。\n全局变量：在函数外部定义的变量或在函数内部使用global关键字修饰的变量。\n作用域：整个程序，直到程序运行结束，全局变量才会被销毁。\n匿名函数 匿名函数lambda：指没有名字的函数，一般在函数的函数体有一句且返回值，只有一个的时候才使用。其语法如下：\nlambda 参数列表：表达式 其中：\nlambda是Python的关键字，参数列表和表达式由用户自定义。 参数列表：它的结构与Python中函数的参数列表是一样的。 表达式：就是函数体，可以有多种形式，比如 a+b,su(a)等。 lambda的特性：\nlambda函数是匿名的，即它是没有名字的函数，并且自带return。 lambda函数可以使用任意数量的参数，但只能包含一个表达式。 lambda函数返回一个值，这个值就是表达式的结果。 lambda函数的生命周期很短，调用后立即被回收。 lambda函数的注意事项：\n匿名函数也可以使用默认参数和可变参数，语法与普通函数相同。\n内部函数 内部函数只能在外部函数中调用\n1 2 3 4 5 6 7 8 9 10 11 def outfnuc(): x = 1 def infunc(): x = 2 print(\u0026#34;内部函数\u0026#34;,x) #调用内部函数 infunc() print(\u0026#34;外部函数\u0026#34;,x) return outfnuc() 也可以以内函数作为返回值进行返回调用,形成闭包函数\n1 2 3 4 5 6 7 8 9 10 def outfnuc(): x = 1 def infunc(): x = 2 print(\u0026#34;内部函数\u0026#34;,x) print(\u0026#34;外部函数\u0026#34;,x) return infunc ret = outfnuc() ret() ","date":"2024-10-09T00:00:00Z","image":"https://UPPO8.github.io/Mybolg/images/PythonCourse/R-C.png","permalink":"https://UPPO8.github.io/Mybolg/p/python-%E5%87%BD%E6%95%B0/","title":"Python-函数"},{"content":"Numpy库 Numpy是Python中的一个扩展程序库，用于大量的维度数组与矩阵运算，同时针对数组运算提供了大量函数库。\n数组的创建 方式一：通过array{}函数将Python的列表或元组转换为数组，数组中的类型是由列表或原组原有的数据类型。\n1 2 3 4 5 import numpy as np a = np.array([2,3,4]) print(a) #打印类型 print(a.dtype) 方式二：Numpy提供了几个常用函数数组。\n1.zeros()创建一个指定大小全零数组 2.ones()创建一个指定大小的全一数组 3.empty()创建一个数组，其内容随机生成 1 2 3 4 5 6 7 import numpy as np a = np.zeros(3,4) b = np.ones(3,4) c = np.empty(3,4) print(a) print(b) print(c) 方式三：通过arrange（）函数得到数组\narrange函数原型arrange(start，end，step)函数的参数中end不包含该值。\n1 2 d = np.arrange(1,5,2) print(d) 矩阵运算 矩阵相乘表示方法：\na = np.array([1,2,3]) b = np.array([4,5,6]) c = a@b 矩阵形状改变 Numpy可以使用raveL()和reshape()函数改变矩阵形状，T函数将矩阵转置。\n1 2 3 4 5 6 7 8 9 10 11 import numpy as np a = np.array([(1,2,3),(4,5,6)]) print(a) #打印形状 print(a.shape) #展平 print(a.ravel()) #修改形状 print(a.reshape(3,2)) #转置 print(a.T) Pandas数据分析库 Series对象是Pandas中的一堆数据结构，能存储不同类型的数据。可以传入数字、列表、字典等类型，将该打印该对象同时会打印索引。\n1 2 3 4 5 6 7 8 9 10 11 import pandas as pd a = pd.Series([1,-5,[1,2],\u0026#34;aa\u0026#34;,{\u0026#34;aa\u0026#34;:555}]) print(a) \u0026#39;\u0026#39;\u0026#39; 打印结果 0 1 1 -5 2 [1, 2] 3 aa 4 {\u0026#39;aa\u0026#39;: 555} \u0026#39;\u0026#39;\u0026#39; Matplotlib绘图库 绘制一个正弦函数示例图：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import matplotlib.pyplot as plt import numpy as np #计算正弦曲线上x，y坐标 x = np.linspace(0, 2 * np.pi, 200) y = np.sin(x) #创建一个子图 fig, ax = plt.subplots() #使用plot绘制图像 ax.plot(x, y) #定义坐标轴和标签 plt.xlabel(\u0026#39;x轴\u0026#39;) plt.ylabel(\u0026#39;y轴\u0026#39;) plt.title(\u0026#39;Sine\u0026#39;) #显示图像 plt.show() 得到正弦函数: ","date":"2024-10-07T00:00:00Z","image":"https://UPPO8.github.io/Mybolg/images/PythonCourse/R-C.png","permalink":"https://UPPO8.github.io/Mybolg/p/python%E7%9A%84%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%931/","title":"Python的第三方库1"},{"content":"数据类型-列表 列表：是一种有序的元素集合，用于存储一组有序的数据，可以包含任意数量的元素，并且每个元素可以是不同的数据类型。与字符串不同的是，列表里的元素是可以修改的。\n其表示方法为:\n列表名称 = [元素1,元素2,....,元素n] 列表的访问方式有下标访问和切片访问.列表的下标访问和切片访问与字符串的索引一样.\n不同的是,列表的切片访问可以访问多个元素\n列表的操作 对列表中内容,主要有增加,删除,修改,查找.\n列表的内容增加: append()像列表尾部加入元素; insert()在列表指定位置加入袁术; extend()将一个列表的所有元素添加到另一个列表 1 2 3 4 5 6 7 8 9 10 11 12 ###append()用法### list1 = [1,2,3] list1.append(4) print(list1) ###insert()用法### list2 = [1,2,3] list2.insert(2,4)#在下标2处插入4 print(list2) ###extend()用法### list1 = [1,2,3] list1.extend([4,5,6]) print(list1) 列表的内容删除: remove(元素)删除指定元素,列表中必须包含该元素 pop(下标)移除列表的一个元素,并返回该元素, clear()删除列表中的所有元素 del 关键字,指定下标时删除对应元素,未指定则删除整个列表对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ls = [1,2,3] #remove删除列表中的\u0026#39;1\u0026#39; print(ls.remove(1)) #打印结果:[2,3] #pop将指定下标的元素取出 print(ls.pop(1)) ##打印结果:2 #clear函数 print(ls.clear()) #打印结果:[] #del是一个关键字,当指定下标时,删除指定元素 del ls[0] del ls #不指定下标时,为删除这个列表吗,后续不可再用 列表的内容修改: 修改格式 列表名[索引] = '新内容' 1 2 3 list1 = [1,2,3,4] list1[0] = 0 print(list1) 列表的内容查找: 1.count()返回列表中某个元素的数量 2.使用in关键字查找,如果存在就返回True,否则返回False 1 2 3 4 5 6 7 8 #count使用 ls = [1,2,3,4,5] print(ls.count(3)) #打印结果:1 #使用in关键字 if 1 in ls: print(\u0026#39;1在列表中\u0026#39;) 列表的其他常用操作: len()获取列表中元素的个数 reverse()反转列表中的元素 sort()对列表元素进行排序(只针对数字型列表) copy()对列表的拷贝 ls[][]列表的嵌套,如ls[[1,2],[3,4]] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #对数字列表排序 list1 = [1,88,36,45,42,9] list1.sort(reverse=True)#默认False从小到大排序 print(list1) #如果想对字符串排序 list1 = [\u0026#39;a\u0026#39;,\u0026#39;bdf\u0026#39;,\u0026#39;de\u0026#39;,\u0026#39;dasdd\u0026#39;] list1.sort(reverse=True,key=len)#依据字符串的长度排序 print(list1) #列表的浅拷贝, l1 = [1,2,3] l2 = l1.copy() #列表的深拷贝 import copy l3 = copy.deepcopy(l1) #列表推导式,如对列表平方 ls = [1,2,3,4,5] squared_ls = [x ** 2 for x in l1] print(squared_ls) 数据类型-元组 元组:与列表相似,不同之处在于元组的元素不可修改.\n元组的表示使用()表示:\n元组名 = (元素1,元素2,...,元素n) 元组元素的访问,有下标与切片访问,与字符串、列表的方式相同.\n元组的常用操作 元组的常用操作: len():获取元组中元素的个数 max():返回元组中元素最大值 min():返回元组中元素最小值 使用in或not in 查找元素是否在元组中 del:删除元组,使用和列表相同\n元组的推导式语法:\nfor 元素 in 元组 if 条件1 序列 元组、列表、字符串的共同点:\n1.都可以通过下标获取每一个元素. 2.第一个元素的下标为0(从左到右). 3.都可以通过切片的方法获取一个范围. 这些共同点简称序列.其中列表是可变序列,元组和字符串是不可变序列.\n序列的操作 min()和max(),可以用于统计序列中最大值和最小值,根据传入的序列和参数的不同有不同的结果.\nlen()函数:用来计算序列的长度或元素的个数.\nsum()函数:求序列元素的和,可以通过start参数来决定求的初始值.\n1 2 s1 = [1,2,3,4,5] print(sum(s1,start=10)) sorted():用于对序列进行排序,与列表的sort函数不同在于,该函数会返回一个全新的列表,原有的序列不会改变.\n1 2 3 4 s = [1,2,3,4,6] print(sorted(s,reverse=True)) s.sort() print(s) reversed():对序列进行反转,该函数会返回一个迭代器,需要通过强转或for循环来观看元素\n1 2 3 s = [1,2,3,4,5,6] for i in reversed(s1): print(i) all():用于判断序列中的所有元素是否为真,返回布尔值.\nany():用于判断序列中的某个元素是否为真,返回布尔值.\n1 2 3 s = [1,2,3,4,5,6] print(all(s)) print(any(s)) enumerate():用于将一个可遍历对象的数据对象中的下标与元素组合起来,返回的是枚举对象(类似:(0,\u0026lsquo;H\u0026rsquo;))\n1 2 3 s = [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;] for i in enumerate(s): print(i) zip():用于将多个可迭代对象中对应位置的元素打包成一个元组,然后返回这一元组.\n1 2 3 4 5 6 7 l1 = [1,2,3] l2 = [4,5,6] l3 = [7,8,9] l4 = zip(l1,l2) print(list(l4)) l5 = zip(l1,l2,l3) print(list(l5)) 此外还有map()函数:对可迭代对象中的每个元素用一个指定的函数;filter()函数:对可迭代对象中的每个元素用一个指定的函数,并返回结果为真的元素.\n数据类型-集合 集合是一个无序的不重复的序列,分为可变和不可变集合.\n可变集合的元素在定义好之后是不可修改的,但集合本身是可以增加三处元素,这意味着集合的元素只能是数字字符串及元组,并且每个元素只能出现一次.\n集合使用花括号{}表示:\n集合名 = {元素1,元素2,...,元素n} 可变集合的添加 add(): 一次添加单个元素.\nupdata():一次添加多个元素.\n1 2 3 4 5 6 set1 = {1,2,3,4,5} set2 = {4,5,6,7} set1.add(7) print(set1) set2.update(\u0026#39;hello\u0026#39;,\u0026#39;world\u0026#39;) print(set2) remove():删除指定的元素,如果不存在,会报错\ndiscard():删除指定的元素,如果不存在,不会报错\npop():删除第一个元素,如果集合为空,会报错\n1 2 3 4 5 6 7 8 set1 = {1,2,3,4,5} set1.remove(2) set1.remove(9) print(set1) set2 = {4,5,8,9} ret = set2.pop() print(ret) 可变集合元素的查找:\nin:使用关键字查找某元素是否存在于集合中.\n部分其他操作:\nlen():计算集合里元素个数\nset():生成一个集合\ncopy():浅拷贝\nclear():清空集合\nintersection():求两个集合的交集\nunion():求两个集合的并集\nissubset():求两个集合是不是子集关系\nissuperset():求两个集合是不是父集关系\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 set1 = set(\u0026#39;abc\u0026#39;) print(set1) set2 = set1.copy() print(set2) #求交集 set3 = {4,5,6} set4 = {1,2,3,4} set5 ={1} print(set3.intersection(set4)) #求并集 print(set3.union(set4)) #求关系 print(set5.issubset(set4)) print(set4.issuperset(set5)) 每日一曲 ","date":"2024-10-02T00:00:00Z","image":"https://UPPO8.github.io/Mybolg/images/PythonCourse/R-C.png","permalink":"https://UPPO8.github.io/Mybolg/p/python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%954/","title":"Python基础语法4"},{"content":"强制数据类型转换 type()函数可以用来查看一个变量的数据类型.目前常见的数据类型用下面几种:\n数据类型 解释 int 整数 float 浮点数 bool 布尔值 str 字符串 list 列表 tuple 元组 set 集合 dict 字典 如果我们想转换数据类型,有两种方式.\n1.显式类型转换\n显式类型转换是强制类型转换,这种转换并不是所有对象都可以安全的转换为任意其他类型,转换的过程中可能会报错.\n2.隐式类型转换\n隐式类型转换则是解释器自动将一种数据类型的值转换为另一种数据类型.\n下面举个例子\n1 2 3 4 5 6 7 8 9 10 11 a = input(\u0026#39;输入整数a:\u0026#39;) b = input(\u0026#39;输入整数b:\u0026#39;) print(a+b) print(type(a)) \u0026#39;\u0026#39;\u0026#39; 打印结果: a:5 b:6 56 \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; \u0026#39;\u0026#39;\u0026#39; 可以看到这里打印的a+b是56,使用type函数发现输入的值以字符串形式存储的,这显然不和要求,因此需要进行输入数据转换\n1 2 3 4 a = int(input(\u0026#39;输入整数a:\u0026#39;)) #或者 a = input(\u0026#39;输入整数a:\u0026#39;) a = int(a) 条件语句 条件语句,也叫做判断语句,简单来说就是如果满足某个条件,就去做某件事,不满足就不做.\n条件语句使用if关键字作判断,使用方式三种判断格式:\nif格式 这是一种基础格式,他的执行逻辑:先执行表达式,如果表达式为真,则执行代码块,否则不会执行.\n1 2 3 4 a = int(input(\u0026#39;输入整数a:\u0026#39;)) b = int(input(\u0026#39;输入整数b:\u0026#39;)) if a \u0026lt; b: print(\u0026#34;a小于b\u0026#34;) if-else格式 if-else执行逻辑:先执行表达式,如果表达式为真,则执行代码块1,否则执行代码块2.\n1 2 3 4 5 6 a = int(input(\u0026#39;输入整数a:\u0026#39;)) b = int(input(\u0026#39;输入整数b:\u0026#39;)) if a \u0026lt; b: print(\u0026#34;a小于b\u0026#34;) else: print(\u0026#34;a大于等于b\u0026#34;) if-elif-else if-elif-else的执行逻辑:先执行表达式1，如果表达式1为真则执行代码块1，否则继续执行表达式2；如果表达式2为真则执行代码块2，否则继续向下执行；如果所有的表达式都为假，则 执行else分支。\n1 2 3 4 5 6 7 8 a = int(input(\u0026#39;输入整数a:\u0026#39;)) b = int(input(\u0026#39;输入整数b:\u0026#39;)) if a \u0026lt; b: print(\u0026#34;a小于b\u0026#34;) elif a == b: print(\u0026#34;a等于b\u0026#34;) else: print(\u0026#34;a大于b\u0026#34;) match-case 在Python3.10版本后,新增加了match case语句,也可以用来作条件判断,处理复杂的条件分支:\n1 2 3 4 5 6 7 8 match subject: case condition1: pass#代码块1 case condition2: pass#代码块2 case _: pass#代码块3 循环语句 在Python中,循环语句是程序重复执行一段代码知道满足特定条件为止的关键结构,共有2种格式:for 和 while 两种.\nwhile循环 while循环语法: 如果满足条件,则进入while循环执行代码块,执行完后返回条件再判断返回结果,直到条件不满足,退出循环.\n如下面求1~100累加和的例子\n1 2 3 4 5 6 i = 0 sum = 0 while i \u0026lt;= 100: sum += i i += 1 print(f\u0026#34;1+2+3+...+100的和为:{sum}\u0026#34;) for循环 for循环可以循环遍历任何序列,比如字符串,列表等可遍历对象,只要可遍历 对象没有遍历完,那么代码块就会一直执行,直到可遍历对象遍历完毕.\n1 2 for 临时变量 in 可遍历对象: 代码块 这里的可遍历对象可以是整数序列,整数列表等,也可以直接用range()函数,直接生成一个整数序列对象.\n1 range(start,stop,step) 从语法上可知,这个整数序列从start开始(不写默认为0);到stop结束,但是不包括stop;step为步长(不写默认为1).如range(2,9,1):返回序列[2,3,4,5,6,7,8]\n1 2 3 4 5 # 使用for和range函数生产9*9乘法表 for i in range(1,10): for j in range(1,i+1): print(f\u0026#34;{j} * {i} = {j*i}\u0026#34;,end=\u0026#39; \u0026#39;) print() 循环控制关键字 在for和while循环中,有三种循环控制关键字.\n1.break:在代码块执行过程中终止循环,并跳出本层循环.\n2.continue:在代码块执行过程中终止本次循环，执行下一次循环.\n3.pass:空语句，相当于一个占位符，它的作用是在语法上需要一个语句，但 程序不需要任何操作时使用。例如,某个语句后面不写内容会报错,就会先用pass占位.\n每日一曲 ","date":"2024-10-01T00:00:00Z","image":"https://UPPO8.github.io/Mybolg/images/PythonCourse/R-C.png","permalink":"https://UPPO8.github.io/Mybolg/p/python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%952/","title":"Python基础语法2"},{"content":"数据类型-数字 在Python中,数字类型包括以下几种:\n1.整型int( ):包括正整数,负整数和0,在程序中的表达与数学上一致\n2.浮点型float( ):小数.\n3.布尔型bool( ):特殊的整型,只用True和False,True为1,False为0.\n4.复数complex( ):与数学上表达式一致,分为实部与虚部,用j表示,多用于科学计算.\n布尔型数据的短路求值 在Python中,布尔型数据的短路求值是一种特殊的逻辑运算规则，当逻辑表达式的某个部分已经能够确定整个表达式的值时，就不再计算表达式的其余部分。 比如在下面个例子中\n1 2 3 4 5 a = 10 b = 0 re1 = a or b re2 = a and b print(re1,re2) 数据类型-字符串 字符串由引号括起来的一系列数字,字母,及中文的组合,并且定义好的字符串是不可修改的.\n1 2 3 4 5 6 7 8 9 10 11 #单引号 src = \u0026#39;hello world\u0026#39; #三引号创建多行字符串 src2 = \u0026#39;\u0026#39;\u0026#39; 闲吟秋景外， 万事觉悠悠。 此夜若无月， 一年虚过秋。 \u0026#39;\u0026#39;\u0026#39; print(src1) print(src2) 转义字符 转义字符：是一种特殊字符，用于表示无法直接表示的字符，以反斜杠“\\”开头。\n常用的转义字符：\n换行符：\\n，用于实现换行。 制表符：\\t，相当于一个Tab。 回车符：\\r，将光标移至当前行的开头。 反斜杠：\\\\，将反斜杠本身转义，使反斜杠本身成为一个普通字符。 单引号与双引号：\\’和\\”，将单引号与双引号转义，使其不再是字符串的标识，而是仅仅只是一个单引号或双引号。 字符串的访问 字符串的访问有下标访问与切片访问。下标访问：所谓的下标，其实就是编号，通过编号就可以找到对应的字符，下标可按照从左至右的顺序开始计算，也可以按照从右至左的顺序开始计算，但是访问的时候下标不能超出范围。\nsrc = 'zhangsan' src[0] = z src[1] = h 切片访问与下标访问类似，都是通过字符串的下标进行的，不同的是，下标访问每次只能访问到单个字符，切片访问可以一次访问到多个字符，其访问方式为：\n字符串名[初始位置：终止位置：步长] 访问时，包括初始位置不包括终止位置，且步长默认为1。如果没有给出初始位置，默认初始位置为开始位置；如果没有给出终止位置，默认终止位置为字符串结束位置，此时访问时包括终止位置。\nsrc = 'zhangsan lisi' print(src[0:10:1]) #打印结果:zhangsan l #从左0开始,到第9个,步长为1,打印输出 字符串的操作 字符串的操作总结来说有:查询、转换、判断、分割等\n查询函数 解释 find() 检测字符串是否包含指定字符，如果是则返回开始的索引值，否则返回-1 index() 检测字符串是否包含指定字符，如果是则返回开始的索引值，否则报错 rfind() 从右向左，检测字符串是否包含指定字符，如果是则返回开始的索引值，否则返回-1 rindex() 从右向左，检测字符串是否包含指定字符，如果是则返回开始的索引值，否则报错 转换函数 解释 lower() 将字符串转换为小写 upper() 将字符串转换为大写 title() 将字符串中每个单词的首字母大写 判断函数 解释 startswith() 如果字符串一obj开头,返回True,否则返回False endswith() 如果字符串以obj结尾，则返回True，否则返回False isspace() 如果字符串只包含空格则返回True，否则返回False isalnum() 如果字符串都是字母或数字则返回True，否则返回False isdigit() 如果字符串都是数字则返回True，否则返回False isalpha() 如果字符串都是字母则返回True，否则返回False 分割函数 解释 partition() 将字符串根据参数分割为三部分 rpartition() 从右向左，将字符串根据参数分割为三部分 split() 将字符串根据参数进行分割，且可以指定分割的次数 splitlines() 按照\\n分割，返回一个列表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #字符串的分割 #partition()函数:将字符串按参数分割 str3 = \u0026#39;hello world hello python\u0026#39; print(str3.partition(\u0026#39;world\u0026#39;)) print(str3.rpartition(\u0026#39;world\u0026#39;)) #split()将字符串分割有限次 print(str3.split(\u0026#39; \u0026#39;,2)) print(str3.splitlines()) #count()函数 print(str3.count(\u0026#39;o\u0026#39;)) #join函数 str4 = \u0026#39;_\u0026#39; str5 = [\u0026#39;hello\u0026#39;,\u0026#39;world\u0026#39;] print(str4.join(str5)) #replace函数 print(str3.replace(\u0026#39;hello\u0026#39;,\u0026#39;nihao\u0026#39;)) #capitalize函数,将首字母大写 print(str3.capitalize()) 每日一曲 ","date":"2024-10-01T00:00:00Z","image":"https://UPPO8.github.io/Mybolg/images/PythonCourse/R-C.png","permalink":"https://UPPO8.github.io/Mybolg/p/python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%953/","title":"Python基础语法3"},{"content":"引言 Python作者：Guido von Rossum(吉多·范·罗苏姆)\n诞生时期：1991年，第一个Python解释器诞生.它是用C语言实现的，并能够调用C语言的库文件.\n编程语言的种类有很多，但目前常用的有C、C++、Java、JavaScript、C#、PHP、Ruby以及Python，并且在2021年Python已经超过C称为第一受欢迎的编程语言.\nPython的优缺点 以下代码使用C语言和Python输出a+b的例子:\n1 2 3 4 5 6 7 8 9 10 11 12 13 -----C语言中----- #include \u0026lt;stdio.h\u0026gt; int main() { int a = 1; int b = 1; printf(\u0026#34;%d\\n\u0026#34;,a + b); return 0; } -----Python----- a = 1 b = 1 print(a + b) 这里的代码我们可以发现,Python中每行代码通常代表一条语句的结束,且不需要任何的符号作为每行的结束符.\n缩进与注释 在Python中，通过缩进来组织代码块，例如函数体、循环体、类等.缩进必须一直，通常使用空格来实现（推荐使用4个空格），也可以使用一个制表符.并且同一级别的代码块具有相同的缩进量，下一级别的代码块应比上级别的代码 块增加一个缩进层级.例如:\n1 2 3 4 5 # 使用for和range函数生产9*9乘法表 for i in range(1,10): for j in range(1,i+1): print(f\u0026#34;{j} * {i} = {j*i}\u0026#34;,end=\u0026#39; \u0026#39;) print() 这个例子中,单行注释以(#)开头,井号(#)所在位置的右边都会被当作注释.多行注释则是三引号\u0026rsquo;\u0026lsquo;\u0026lsquo;或\u0026quot;\u0026quot;\u0026quot;,引号中间的内容注释掉.\n1 2 3 4 5 6 7 \u0026#39;\u0026#39;\u0026#39; # 求1到100的和 sum = 0 for i in range(1,101,1): sum += i print(sum) \u0026#39;\u0026#39;\u0026#39; 变量与关键字 变量的三个基本属性:\nid号:反映的是变量值的内存地址.\n类型:每一个变量都有自己的类型.\n值:存储的数据.\n1 2 3 4 5 6 7 8 9 10 # 查看变量id好id() # 查看变量类型type() # 使用 is 或 is not 比较两个变量的id号是否相同 a = 2 b = \u0026#39;nihao\u0026#39; c = 2 print(id(a), id(b), id(c)) print(type(a), type(b), type(c)) print(a is b ,a is c) 输出结果:\n1 2 3 140719832613704 3081789329776 140719832613704 \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; False True 输出结果中可以发现,a和c的id号与类型是一致的,使用is判断返回结果为True.\n变量命名的注意事项:\n1.只能包含字母、数字、下划线，但不能以数字开头。\n2.不能包含空格，但是可以使用下划线来分割名称。\n3.不能使用Python的关键字作为标识符的名称。\nPython运算符 在Python中，常用的运算符分为以下几类：\n算数运算符 算术运算符包括以下几种：\n+：加法运算符，返回两个对象的和\n-：减法运算符，返回两个对象的差\n*：乘法运算符，返回两个对象的积\n/：除法运算符，返回两个对象的商\n//：整除运算符，返回两个对象的商的整数部分\n%：取余运算符，返回两个对象的商的余数部分\n**：平方运算符：返回两个对象的平方运算的结果\n比较运算符 比较运算符包括以下几种：\n==：等于，比较两个对象是否相等，返回布尔值\n！=：不等于，比较两个对象是否不相等，返回布尔值\n＞：大于，比较两个对象的大小关系，返回布尔值\n\u0026lt;：小于，比较两个对象的大小关系，返回布尔值\n＜=：大于等于，比较两个对象的大小关系，返回布尔值\n\u0026lt;=：小于等于，比较两个对象的大小关系，返回布尔值\n逻辑运算符 逻辑运算符 逻辑运算符包括以下几种： and：布尔与，and两边都为True时，才会返回True，只要有一个为False，就会返回False\nor：布尔或，or两边都为False时，才会返回False，只要有一个为True，就会返回True\nnot：布尔非，将True改为False，将False改为True\n赋值运算符 赋值运算符包括以下几种： =：赋值运算符，把=右边的对象赋值给=左边的对象\n+=：加法赋值运算符\n-=：减法赋值运算符\n*=：乘法赋值运算符\n/=：除法赋值运算符\n//=：整除赋值运算符\n%=：取余赋值运算符\n**=：平方赋值运算符\n位运算符 位运算符包括以下几种：\n\u0026amp;：按位与，对两个数据的补码进行位与位之间的与运算，全1为1，有0则0\n|：按位或，对两个数据的补码进行位与位之间的或运算，全0为0，有1则1\n^：按位异或，对两个数据的补码进行位与位之间的异或运算，相同为0，同为1\n运算符的优先级 运算符的优先级（从上向下排列，上面的优先级最高）：\n圆括号()：圆括号内的表达式拥有最高优先级\n**：乘方运算\n*、/、%、//：算术运算符，先乘除\n+、-：算数运算符，后加减\n\u0026laquo;、\u0026raquo;：位运算符的左移与右移\n\u0026amp;：位运算符的按位与\n^：位运算符的按位异或\n|：位运算符的按位或\n＞、＜、\u0026gt;=、\u0026lt;=、==、!=：比较运算符\nand、or：逻辑运算符\n=、+=等赋值运算符优先级最低\n输入与输出 在Python中，使用内置的print()函数进行输出，并且有几种不同的输出方式如下所示：\n基本输入输出： 使用input()输入,使用print()输出,直接打印数据或变量:\n1 2 a = 2 print(a) 格式化输出： 使用百分号(%)格式符:\n格式符 解释 %c 字符 %s 字符串 %d 有符号十进制整数 %f 浮点数 %e 科学计数法 %o 八进制整数 现在不推荐使用，但是旧版本的代码中很常见.\n1 2 a = 2 print(\u0026#39;%d\u0026#39;,a) format()方法： 使用花括号{}作为占位符来指定要格式化的数据类型和格式，然后通过将数据插入到占位符中来生成最后的输出结果。\n1 2 3 4 5 6 7 #用format方法 name = \u0026#39;zhangsan\u0026#39; age = 18 weight = 55.55632 print(\u0026#34;My name is {} and {} years old and {} weight\u0026#34;.format(name,age,weight)) # 控制浮点数精度 :.nf,n为位数\\n\u0026#34;, print(\u0026#34;My name is {} and {} years old and {:.4f} weight\u0026#34;.format(name,age,weight)) f-string： 在字符串前加一个f或F，然后在输出的内容中加上花括号{}，花括号{}里面是要输出的表达式，是一种新的字符串格式方法，在Python3.6版本之后引入的输出方法。\n1 2 3 4 5 6 7 #用format方法 name = \u0026#39;zhangsan\u0026#39; age = 18 weight = 55.55632 print(f\u0026#34;My name is {name} and {age} years old and {weight} weight\u0026#34;) # 控制浮点数精度 :.nf,n为位数\\n\u0026#34;, print(f\u0026#34;My name is {name} and {age} years old and {weight:.2f} weight\u0026#34;) 六大基本数据类型 数据类型 解释 mymum = 11 数值 myfloat = 3.141 浮点数 mystr = \u0026lsquo;hello\u0026rsquo; 字符串 mylist = [1,2,3,4] 列表 mytuple = (1,2,3,4) 元组: myset = {1,2,3,4} 集合 mydict = {\u0026ldquo;key1\u0026rdquo;:\u0026ldquo;value1\u0026rdquo;} 字典 强制数据类型转换函数\n函数 解释 int(x) 转换为整数 float(x) 转换为浮点数 str(x) 转换为字符串 tuple(s) 序列转换为元组 list(s) 序列转换为列表 hex(s) 序列转换为16进制 每日一曲 ","date":"2024-09-30T00:00:00Z","image":"https://UPPO8.github.io/Mybolg/images/PythonCourse/write-plan.jpg","permalink":"https://UPPO8.github.io/Mybolg/p/python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%951/","title":"Python基础语法1"},{"content":"使用Python爬取百度图片\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from fake_useragent import UserAgent import requests import re import uuid headers = {\u0026#34;User-agent\u0026#34;: UserAgent().random, # 随机生成一个代理请求 \u0026#34;Accept-Encoding\u0026#34;: \u0026#34;gzip, deflate\u0026#34;, \u0026#34;Accept-Language\u0026#34;: \u0026#34;zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6\u0026#34;, \u0026#34;Connection\u0026#34;: \u0026#34;keep-alive\u0026#34;, \u0026#34;cookie\u0026#34;: \u0026#39;BAIDU_WISE_UID=wapp_1726906421787_41; ZFY=cggvvWz7Y:AvYezL06fvqCimMOCYkqDMtbJ5RzE0wB1Y:C; BAIDUID_BFESS=316C0566E374307EC37BCF07E6F2F4AF:FG=1; newlogin=1; BIDUPSID=316C0566E374307EC37BCF07E6F2F4AF; BDRCVFR[dG2JNJb_ajR]=mk3SLVN4HKm; H_WISE_SIDS=60829; BDRCVFR[-pGxjrCMryR]=mk3SLVN4HKm; BDRCVFR[tox4WRQ4-Km]=mk3SLVN4HKm; BDRCVFR[A24tJn4Wkd_]=mk3SLVN4HKm; BDRCVFR[X_XKQks0S63]=mk3SLVN4HKm; firstShowTip=1; cleanHistoryStatus=0; RT=\u0026#34;z=1\u0026amp;dm=baidu.com\u0026amp;si=a0fa21b3-7bde-440a-966a-404ccd3e6fdd\u0026amp;ss=m1w0jp0l\u0026amp;sl=i\u0026amp;tt=7cg\u0026amp;bcn=https%3A%2F%2Ffclog.baidu.com%2Flog%2Fweirwood%3Ftype%3Dperf\u0026amp;ld=3luz\u0026amp;ul=4pvi\u0026amp;hd=4q6a\u0026#34;; indexPageSugList=%5B%22cat%22%2C%22dog%22%5D; ab_sr=1.0.1_MzQwMjZkMGYwMTM5ZjAzOWYzMGZlMTU2ZjFhOWZkMjlkNDk2NjQzZTdmOTFlYmZkZDFmMjA2YjM3Y2E4YzgxYzU3MTJlYWQ0NjNiNTQwZGM4ZTJiNThmMzBlN2IzMGNmYzI3NzNhMTNhYTc2M2VmODkwZTNjMmJmYTRhNTRmNmE0YTAyNWFiY2UwZGFlM2I4YmM3MGRmM2QxYzcwYjg3Ng==\u0026#39; } img_re = re.compile(\u0026#39;\u0026#34;thumbURL\u0026#34;:\u0026#34;(.*?)\u0026#34;\u0026#39;) img_format = re.compile(\u0026#34;f=(.*).*?w\u0026#34;) def file_op(img): uuid_str = uuid.uuid4().hex tmp_file_name = \u0026#39;E:/HQYJ/course1/images/%s.jpeg\u0026#39; % uuid_str with open(file=tmp_file_name, mode=\u0026#34;wb\u0026#34;) as file: try: file.write(img) except: pass def xhr_url(url_xhr, start_num=0, page=5): end_num = page * 30 for page_num in range(start_num, end_num, 30): resp = requests.get(url=url_xhr + str(page_num), headers=headers) if resp.status_code == 200: img_url_list = img_re.findall(resp.text) # 这是个列表形式 for img_url in img_url_list: img_rsp = requests.get(url=img_url, headers=headers) file_op(img=img_rsp.content) else: break print(\u0026#34;内容已经全部爬取\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: org_url = \u0026#34;https://image.baidu.com/search/acjson?tn=resultjson_com\u0026amp;word={text}\u0026amp;pn=\u0026#34;.format( text=input(\u0026#34;输入你想检索内容:\u0026#34;)) xhr_url(url_xhr=org_url, start_num=int(input(\u0026#34;开始页:\u0026#34;)), page=int(input(\u0026#34;所需爬取页数:\u0026#34;))) ","date":"2024-09-30T00:00:00Z","permalink":"https://UPPO8.github.io/Mybolg/p/%E4%BD%BF%E7%94%A8python%E7%88%AC%E5%8F%96%E7%99%BE%E5%BA%A6%E5%9B%BE%E7%89%87/","title":"使用Python爬取百度图片"},{"content":"添加网易云音乐: 在网易云音乐页面,点击一首歌曲, 例如:大鱼 点击生成外链播放器,得到该音乐的HTML插入代码,然后在你的文章md中插入改代码即可播放音乐了.\n添加QQ音乐: QQ音乐获取外链教程具体见:如何获得QQ音乐官方外链播放器并嵌入进网页\n","date":"2024-09-30T00:00:00Z","permalink":"https://UPPO8.github.io/Mybolg/p/%E7%BD%91%E9%A1%B5%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/","title":"网页嵌入式音乐播放器"}]